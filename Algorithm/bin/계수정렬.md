# 1. 계수 정렬 (Count Sort)

> 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
>
> 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용할 수 있다.
>
> 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언한다.

계수 정렬은 최악의 경우에도 수행 시간 O(N+K)를 보장한다.

데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다. 일반적으로 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적으로 사용할 수 있다.

가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크다면 계수 정렬은 사용할 수 없다.

가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000이면 총 1,000,001개의 수가 존재한다.

직접 데이터의 값을 비교한 뒤에 위치를 변경하며 정렬하는 방식(비교 기반의 정렬 알고리즘)이 아니다.

계수 정렬은 데이터의 크기가 제한되어 있을 때에 한해서 데이터의 개수가 매우 많더라도 빠르게 동작한다.

가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다. 가장 큰 데이터가 '9'이고 가장 작은 데이터가 '0'이다. 따라서 정렬할 데이터의 범위는 0부터 9까지이므로 리스트의 인덱스가 모든 범위를 포함할 수 있도록 한다. 크기가 10인 리스트의 모든 데이터가 0이 되도록 초기화한다.

그리고 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수 정렬이 완료된다.

정렬된 결과는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 인덱스를 출력한다.

### A. 소스 코드

##### a. 책에 나온 예시

```python

array = [7, 5, 6, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2, 99, 150]  
  
count = [0] * (max(array) + 1)  
  
for i in array:  
    count[i] = count[i] + 1  
  
print("count = ", count)  
  
print("sorted = ", end='')  
for j in range(len(count)):  
    for k in range(count[j]):  
        print(j, end=' ')
		
```

```

count =  [2, 2, 2, 1, 1, 2, 2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]

sorted = 0 0 1 1 2 2 3 4 5 5 6 6 7 8 9 99 150 

```

##### b. 내가 생각한 코드

아래 공간 복잡도 문제를 제시하길래, "어? 그럼 딕셔너리를 사용하면 공간 복잡도 문제는 해결되는 것 아닌가?"하면서 코드를 작성했다.

아.. 이러면 sorted 함수를 사용하니까 공간 복잡도는 해결해도 시간 복잡도는 증가하겠구나..

```python

array = [7, 5, 6, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2, 99, 150]  
  
count = dict()  
  
for i in array:  
    if i in count:  
        count[i] = count[i] + 1  
 else:  
        count[i] = 1  
  
count = sorted(count.items(), key=lambda x:x[0])  
  
print("count = ", count)  
  
print("sorted = ", end='')  
for i_key, i_value in count:  
    for j in range(i_value):  
        print(i_key, end=' ')

```

```

count =  [(0, 2), (1, 2), (2, 2), (3, 1), (4, 1), (5, 2), (6, 2), (7, 1), (8, 1), (9, 1), (99, 1), (150, 1)]
sorted = 0 0 1 1 2 2 3 4 5 5 6 6 7 8 9 99 150 

```

### B. 시간 복잡도

계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐만 아니라, 추후에 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최댓값의 크기만큼 반복을 수행한다.

기수 정렬(Radix Sort)과 더불어 가장 빠르다고 볼 수 있다. 기수 정렬은 계수 정렬에 비해서 동작은 느리지만, 처리할 수 있는 정수의 크기는 더 크다.

### C. 공간 복잡도

계수 정렬은 때에 따라 심각한 비효율성을 초래할 수 있다. 데이터가 0과 999,999 단, 2개만 존재하는 경우 리스트의 크기가 100만 개가 되도록 선언해야 한다.

따라서 항상 사용할 수 있는 알고리즘은 아니고, 동일한 값을 가지는 데이터가 여러 개 등장했을 때 적합하다.

데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다. 하지만 조건을 만족하면 데이터의 개수가 매우 많을 때도 효과적으로 사용할 수 있다.

코테 시스템 환경에서는 메모리 공간상의 제약과 입출력 시간 문제로 인하여 입력되는 데이터의 개수를 1,000만 개 이상으로 설정할 수 없는 경우가 많기 때문에, 정렬 문제에서의 데이터 개수는 1,000만 개 미만으로 출제될 것이다.

# 참고문헌

나동빈, "이것이 취업을 위한 코딩 테스트다 with 파이썬", 초판, 2쇄, 한빛미디어, 2020년

#코딩테스트 #파이썬 #나동빈 #한빛미디어 #이것이취업을위한코딩테스트다 #계수정렬