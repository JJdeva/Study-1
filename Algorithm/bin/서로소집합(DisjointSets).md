# 1. 서로소 집합

서로소 집합이란 공통 원소가 없는 두 집합을 의미한다.

![서로소집합](/bin/PS_image/서로소집합(DisjointSets)_개념.png)

서로소 집합 자료구조란 **서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조**. union과 find 2개의 연산으로 조작할 수 있다.

union 연산은 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산이다. find 연산은 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산이다.

서로소 집합 자료구조는 union-find 자료구조라고 불리기도 한다. 두 집합이 서로소 관계인지를 확인할 수 있다는 말은 각 집합이 어떤 원소를 공통으로 가지고 있는지를 확인할 수 있다는 말과 같기 때문이다.

### A. 서로소 집합 자료구조

서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현한다. 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘은 다음과 같다.

1. union(합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
	1. A와 B의 루트 노드 A', B'를 각각 찾는다.
	2. A'를 B'의 부모 노드로 설정한다 (B' -> A')
2. 모든 union(합집합) 연산을 처리할 때까지 1번 과정을 반복한다.

실제로 구현할 때는 A'와 B' 중에서 더 번호가 작은 원소가 부모 노드가 되도록 구현하는 경우가 많다.

union 연산들은 그래프 형태로 표현될 수도 있다. 각 원소는 그래프에서의 노드로 표현되고, **같은 집합에 속한다.** 는 정보를 담은 union 연산들은 간선으로 표현된다.

실제로는 각 원소의 집합 정보를 표현하려면 트리 자료구조를 이용한다. 서로소 집합을 그림으로 표현할 때는 번호가 큰 노드가 번호가 작은 노드를 간선으로 가리키도록 트리 구조를 이용해 그림을 그리게 된다.

![서로소집합](/bin/PS_image/서로소집합(DisjointSets)_예시.png)

이렇게 union 연산을 토대로 그래프를 그리면 **연결성**으로 쉽게 집합의 형태를 확인할 수 있다.

### B. 서로소 집합 알고리즘

union 연산을 하나씩 확인하면서 서로 다른 두 원소에 대해 합집합을 수행해야 할 때는, 각각 루트 노드를 찾아서 더 큰 루트 노드가 더 작은 루트 노드를 가리키도록 하면 된다.

##### a. 예시

- step 0

	가장 먼저 노드의 개수(V) 크기의 부모 테이블을 초기화한다. 이때 모든 원소가 자기 자신을 부모로 가지도록 설정한다. 부모 테이블은 부모에 대한 정보만을 담고 있다. 다시 말해 특정한 노드의 부모에 대해서만 저장하고 있다. 우리가 실제로 루트를 확인하고자 할 때는 재귀적으로 부모를 거슬러 올라가서 최종적인 루트 노드를 찾아야 한다.

	| 노드 번호 | 1   | 2   | 3   | 4   | 5   | 6   |
	| --------- | --- | --- | --- | --- | --- | --- |
	| 부모      | 1   | 2   | 3   | 4   | 5   | 6   |

- step 1

	> union 1, 4

	현재 루트 노드는 각각 1과 4이기 때문에 더 큰 번호에 해당하는 루트 노드 4의 부모를 1로 설정한다.

	| 노드 번호 | 1   | 2   | 3   | 4   | 5   | 6   |
	| --------- | --- | --- | --- | --- | --- | --- |
	| 부모      | 1   | 2   | 3   | 1   | 5   | 6   |

- step 2

	> union 2, 3

	현재 루트 노드는 각각 2와 3이기 때문에 더 큰 번호에 해당하는 루트 노드 3의 부모를 2로 설정한다.

	| 노드 번호 | 1   | 2   | 3   | 4   | 5   | 6   |
	| --------- | --- | --- | --- | --- | --- | --- |
	| 부모      | 1   | 2   | 2   | 1   | 5   | 6   |

- step 3

	> union 2, 4

	현재 루트 노드는 각각 2와 1이기 때문에 더 큰 번호에 해당하는 루트 노드 2의 부모를 1로 설정한다.

	| 노드 번호 | 1   | 2   | 3   | 4   | 5   | 6   |
	| --------- | --- | --- | --- | --- | --- | --- |
	| 부모      | 1   | 1   | 2   | 1   | 5   | 6   |

- step 4

	> union 5, 6 

	현재 루트 노드는 각각 5와 6이기 때문에 더 큰 번호에 해당하는 루트 노드 6의 부모를 5로 설정한다.

	| 노드 번호 | 1   | 2   | 3   | 4   | 5   | 6   |
	| --------- | --- | --- | --- | --- | --- | --- |
	| 부모      | 1   | 1   | 2   | 1   | 5   | 5   |

##### b. 결론

유의할 점은 union 연산을 효과적으로 수행하기 위해 **부모 테이블**을 항상 가지고 있어야 한다는 점이다. 루트 노드를 즉시 계산할 수 없고, 부모 테이블을 계속해서 확인하며 거슬러 올라가야 한다.

서로소 집합 알고리즘으로 루트를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야 한다는 점을 기억하자.

##### c. 소스코드

```python

def find_parent(parent, x):  
    if parent[x] != x:  
        return find_parent(parent, parent[x])  
 
    return x  
  
def union_parent(parent2, a, b):  
    a = find_parent(parent2, a)  
    b = find_parent(parent2, b)  
  
    if a<b:  
        parent2[b] = a  
    else:  
        parent2[a] = b  
  
v, e = map(int, input().split())  
parent = [0] * (v+1)  
  
for i in range(1, v+1):  
    parent[i] = i  
  
for i in range(e):  
    a, b = map(int, input().split())  
    union_parent(parent, a, b)  
  
print('각 원소가 속한 집합: ', end='')  
for i in range(1, v+1):  
    print(find_parent(parent, i), end=' ')  
  
print()  
  
print('부모 테이블: ', end='')  
for i in range(1, v+1):  
    print(parent[i], end=' ')

```

##### d. 경로 압축 (Path Compression)

위 코드의 find 함수가 비효율적으로 동작한다. 최악의 경우 find 함수가 모든 노드를 다 확인하는 터라 시간 복잡도가 O(V)라는 점이다.

현재 알고리즘을 그대로 이용하게 되면 노드의 개수가 V개이고 find 혹은 union 연산의 개수가 M개일 때, 전체 시간 복잡도는 O(VM)이 되어 비효율적이다.

find 함수는 간단한 과정으로 최적화가 가능하다. 경로 압축기법을 적용하면 시간 복잡도를 개선시킬 수 있다. 경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블값을 갱신하는 기법이다.

![서로소집합](/bin/PS_image/서로소집합(DisjointSets)_경로압축.png)

```python

# 경로 압축  
  
def find_parent(parent, x):  
    if parent[x] != x:  
        parent[x] = find_parent(parent, parent[x])  
  
    return parent[x]
	
```

각 노드에 대하여 find 함수를 호출한 이후에, 해당 노드의 루트 노드가 바로 부모 노드가 된다. 모든 union 함수를 처리한 후 각 원소에 대하여 find 함수를 수행하면 다음과 같이 부모 테이블이 형성된다. 경로 압축 기법을 이용하게 되면 루트 노드에 더욱 빠르게 접근할 수 있어서 시간 복잡도가 개선된다.

![서로소집합](/bin/PS_image/서로소집합(DisjointSets)_경로압축_2.png)

##### e. 서로소 집합 알고리즘의 시간 복잡도

노드의 개수가 V개이고, 최대 V-1개의 union 연산과 M개의 find연산이 가능할 때 경로 압축 방법만을 이용할 경우의 시간 복잡도는 O($V + M(1 + \log_{2-M/V}V$)) 이다.

### C. 서로소 집합을 활용한 사이클 판별

서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 있다. 방향 그래프에서의 사이클 여부는 DFS를 이용하여 판별할 수 있다.

union연산은 그래프에서의 간선으로 표현될 수 있다고 했다. 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.

1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
	1. 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
	2. 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것이다.
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.


##### a. 소스 코드

```python

def find_parent(parent, x):  
    if parent[x] != x:  
        parent[x] = find_parent(parent, parent[x])  
    return parent[x]  
  
def union_parent(parent, a, b):  
    a = find_parent(parent, a)  
    b = find_parent(parent, b)  
  
    if a<b:  
        parent[b] = a  
    else:  
        parent[a] = b  
  
v, e = map(int, input().split())  
parent = [0] * (v+1)  
  
for i in range(1, v+1):  
    parent[i] = i  
  
cycle = False  
  
for i in range(e):  
    a, b = map(int, input().split())  
  
    if find_parent(parent, a) == find_parent(parent, b):  
        cycle = True  
 		break 
	else:  
        union_parent(parent, a, b)  
  
if cycle:  
    print("사이클이 발생했습니다.")  
else:  
    print("사이클이 발생하지 않았습니다.")
	
```


##### b. 이상한 예시

![서로소집합](/bin/PS_image/서로소집합(DisjointSets)_cycle.png)

# 참고문헌

나동빈, "이것이 취업을 위한 코딩 테스트다 with 파이썬", 초판, 2쇄, 한빛미디어, 2020년

#코딩테스트 #파이썬 #나동빈 #한빛미디어 #이것이취업을위한코딩테스트다 #개념 #서로소집합