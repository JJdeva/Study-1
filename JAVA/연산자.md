# 1. 연산자와 피연산자

연산자는 **연산을 수행하는 기호**를 말한다.

연산자가 연산을 수행하려면 반드시 연산의 대상이 있어야하는데, 이것을 **피연산자(operand)** 라고 한다.

`x + 3`

- 피연산자
	- x
	- 3
- 연산자
	- +

덧셈 연산자 '+'는 두 값을 더한 결과를 반환하므로, 두 개의 피연산자를 필요로 한다.

연산자와 피연산자를 조합하여 계싼하고자 하는 바를 표현한 것을 **식(expression)** 이라고 한다. 식을 계산하여 결과를 얻는 것을 **식을 평가(evaluation)한다**고 한다. 하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다.

`4 * x + 3`
-> `4 * 5 + 3`
-> `23`

식이 평가되어 23이라는 결과를 얻었다.

대입 연산자 `=`를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장한다.

`y = 4 * x + 3`

그 다음에 변수 y에 저장된 값을 다른 곳에 사용하거나 화면에 출력함으로써 의미있는 결과를 얻을 수 있다.

# 2. 연산자의 종류

| 종류        | 연산자                   | 설명                                         |
| ----------- | ------------------------ | -------------------------------------------- |
| 산술 연산자 | +, -, \*, \/, %, <<, >>  | 사칙 연산과 나머지 연산 (%)                  |
| 비교 연산자 | >, <, >=, <=, \=\=, !=   | 크고 작음과 같고 다름을 비교                 |
| 논리 연산자 | &&, \|\|, !, &, \|, ^, ~ | '그리고(AND)'와 '또는(OR)'으로 조건을 연결   |
| 대입 연산자 | =                        | 우변의 값을 좌변에 저장                      |
| 기타        | (type) ?: instanceof     | 형변환 연산자, 삼항 연산자, instanceof연산자 |

피연산자의 개수가 하나면 **단항 연산자**, 두개면 **이항 연산자**, 세개면 **삼항 연산자**라고 부른다.

서로 다른 연산자의 기호가 같은 경우도 있는데, 이럴 때는 피연산자의 개수로 구분이 가능하다.

연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 것은 **연산자의 우선순위** 떄문이기도 하다.

# 3. 연산자의 우선순위

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.

- 비교 연산자(>)보다 산술 연산자 '+'와 '-'가 먼저 수행된다.
- 논리 연산자(&&)보다 비교 연산자가 먼저 수행된다.
- 대입 연산자는 연산자 중에서 제일 우선순위가 낮다

# 4. 연산자의 결합규칙

우선순위가 같다고 해서 아무거나 먼저 처리하는 것은 아니고 나름대로 규칙을 가지고 있는데, 그 규칙을 **연산자의 결합규칙**이라고 한다.

`3 + 4 - 5`

덧셈연산자 `+`의 방향이 왼쪽에서 오른쪽이므로 왼쪽에서 오른쪽으로 연산이 진행된다.

`x = y = 3`

대입 연산자는 연산자의 결합규칙이 오른쪽에서 왼쪽이므로, 오른쪽의 대입연산자부터 처리한다.

대입 연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다.

1. 산술 > 비교 > 논리 > 대입
	- 대입은 제일 마지막에 수행된다.
2. 단항 (1) > 이항 (2) > 삼항 (3)
	- 단항 연산자의 우선순위가 이항 연산자보다 높다
3. 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.

# 5. 증감 연산자 ++과 --

증감 연산자는 피연산자에 저장된 값을 1 증가 또는 감소시킨다. 피연산자로 정수와 실수가 모두 가능하지만, 상수는 값을 변경할 수 없으므로 가능하지 않다.

> 증감 연산자는 일반 산술 변환에 의한 자동 형변환이 발생하지 않으며, 연산결과의 타입은 피연산자의 타입과 같다.

- 증가 연산자(++)
	- 피연산자의 값을 1 증가시킨다.
- 감소 연산자(--)
	- 피연산자의 값을 1 감소시킨다.

증가 연산자 `++`와 감소 연산자 `--`는 양쪽 모두 가능하다. 피연산자의 왼쪽에 위치하면 `전위형(prefix)`, 오른쪽에 위치하면 `후위형(postfix)`이라고 한다.

- 전위형
	- 값이 참조되기 전에 증가시킨다.
	- ++i
- 후위형
	- 값이 참조된 후에 증가시킨다.
	- i++

`++i`와 `i++`처럼 증감연산자가 수식이나 메서드 호출에 포함되지 않고 독립적인 하나의 문장으로 쓰인 경우에는 전위형과 후위형의 차이가 없다.

```java

class Ex3_2 {
	public static void main(String args[]) {
		int i=5, j=0;

		j = i++;
		System.out.println("j=i++; 실행 후, i=" + i +", j="+ j);

		i=5;        // 결과를 비교하기 위해, i와 j의 값을 다시 5와 0으로 변경
		j=0;

		j = ++i;
		System.out.println("j=++i; 실행 후, i=" + i +", j="+ j);
		
		char a = 'a';
		a++;
		char b = 'b';
		b++;
		System.out.println(a + b);
		
	}
}

```

전위형은 변수(피연산자)의 값을 먼저 증가시킨 후에 변수의 값을 읽어오는 반면, 후위형은 변수의 값을 먼저 읽어온 후에 값을 증가시킨다.

# 6. 부호 연산자

부호 연산자 `-`는 피연산자의 부호를 반대로 변경한 결과를 반환한다. 피연산자가 음수면 양수, 양수면 음수가 연산의 결과가 된다.

부호 연산자는 boolean형과 char형을 제외한 기본형에만 사용할 수 있다.

# 7. 형변환 연산자

같은 타입뿐만 아니라 서로 다른 타입 간의 연산을 수행해야 하는 경우도 있다. 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 **형변환(casting)** 이라고 한다.

형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입의 괄호와 함께 붙여주기만 하면 된다.

`(타입)피연산자`

여기에 사용되는 괄호()는 **캐스트 연산자** 또는 **형변환 연산자**라고 하며, 형변환을 **캐스팅(casting)** 이라고도 한다.

형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이다. 그래서 피연산자인 변수 d의 값은 형변환 후에도 아무런 변화가 없다.

# 8. 자동 형변환

컴파일러가 생략된 형변환을 자동적으로 추가해준다.

`float f = 1234;`

float 타입의 변수는 1234라는 값을 저장하는데 아무런 문제가 없다.

그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생한다.

`byte b = 1000;`

다음과 같이 명시적으로 형변환을 해줬을 경우, 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

`byte b = (byte)1000;`

형변환을 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서인데, 형변환을 생략하면 컴파일러가 알아서 자동적으로 형변환을 한다.

> 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다.

표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓은 쪽으로 형변환된다.

byte -> short -> int -> long -> float -> double
			char -> int

왼쪽부터 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은 반드시 형변환 연산자를 써야 한다.

# 9. 사칙 연산자

곱셈(\*), 나눗셈(\/), 나머지(%) 연산자가 덧셈(+), 뺄셈(-) 연산자보다 우선순위가 높으므로 먼저 처리된다.

피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 만일 0으로 나눈다면, 실행 시에 에러가 발생한다.

```java

class Ex3_6 {
	public static void main(String args[]) { 
		int a = 10;
		int b = 4;

		System.out.printf("%d + %d = %d%n",  a, b, a + b);
		System.out.printf("%d - %d = %d%n",  a, b, a - b);
		System.out.printf("%d * %d = %d%n",  a, b, a * b);
		System.out.printf("%d / %d = %d%n",  a, b, a / b);
		System.out.printf("%d / %f = %f%n",  a, (float)b, a / (float)b);
				
	}
}

```

나누기 연산자의 두 피연산자가 모두 int타입인 경우, 연산결과 역시 int 타입이다. 그래서 실제 연산결과는 2.5일지라도 int 타입의 값인 2를 결과로 얻는다. 이때, 반올림이 발생하지 않는다.

올바른 연산겨로가를 얻기 위해서는 두 피연산자 중 어느 한 쪽을 실수형으로 형변환해야 한다. 그래야만 다른 한 쪽도 같이 실수형으로 자동 형변환되어 결국 실수형의 값을 결과로 얻는다.

`10 / 4.0f -> 10.0f / 4.0f -> 2.5f`

두 피연산자의 타입이 일치하지 않으므로 int타입보다 범위가 넓은 float타입으로 일치시킨 후에 연산을 수행하는 것을 알 수 있다. float타입과 float타입의 연산이므로 연산겨로가 역시 float타입이다.

# 10. 산술 변환

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.

연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 **산술 변환**또는 **일반 산술 변환**이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.

1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
	- long + int -> long + long -> long
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.
	- byte + short -> int + int -> int

첫 번째 규칙은 피연산자의 값손실을 최소화하기 위한 것
두 번째 규칙은 int보다 작은 타입, char, short의 표현범위가 좁아서 연산중에 오버플로우(overflow)가 발생할 가능성이 높기 때문에 있는 것이다.

연산결과의 타입은 피연산자의 타입과 일치한다.

`5 / 2 -> 2(int)`

2.5라는 실수를 얻으려면, 피연산자 중 어느 한 쪽을 float와 같은 실수형으로 형변환해야 한다. 그러면, 다른 한 쪽은 일반 산술 변환의 첫 번째 규칙에 의해 자동적으로 형변환되어 두 피연산자 모두 실수형이 되고, 연산결과 역시 실수형의 값을 얻을 수 있다.

`5 / (float)2 -> 5 / 2.0f -> 5.0f / 2.0f -> 2.5f`

산술 변환이란, 그저 연산 직전에 발생하는 자동 형변환일 뿐이다.

```java

byte a =10;
byte b = 20;
byte c = a + b;

```

위 코드는 컴파일하면 에러가 발생한다.

a와 b는 모두 int형보다 작은 byte형이기 때문에 연산자 `+`는 이 두 개의 피연산자들의 자료형을 int형으로 변환한 다음 연산(덧셈)을 수행한다.

그래서 `a + b`의 연산결과는 byte형이 아닌 int형(4 byte)인 것이다.

크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환(type conversion, casting)되지만, 반대로 큰 자료형의 값을 작은 자료형의 변수에 저장하려면 명시적으로 형변환 연산자를 사용해서 변환해주어야 한다.

```java

class Ex3_8 {
	public static void main(String[] args) {
		byte a = 10;
		byte b = 30;
		byte c = (byte)(a * b);
		System.out.println(c);
	}
}

```

이 예제는 44를 출력한다. 10 \* 30의 결과는 300이지만, 형변환(캐스팅, casting)에서 배운 것처럼, 큰 자료형에서 작은 자료형으로 변환하면 데이터의 손실이 발생하므로 값이 바뀔 수 있다. 300은 byte형의 범위를 넘기 때문에 byte형으로 변환하면 데이터 손실이 발생하여 44가 저장된다.

```java

class Ex3_9 {
	public static void main(String args[]) { 
		int a = 1_000_000;    // 1,000,000   1백만 
		int b = 2_000_000;    // 2,000,000   2백만 

		long c = a * b;       // a * b = 2,000,000,000,000 ?

		System.out.println(c);
	}
}

```

위 결과는 -1454759936이 나온다.
long 타입(8byte)이기 때문에 2000000000000가 나올 것 같지만, int타입과 int타입의 연산결과는 int타입이기 때문에 `a * b` 의 결과가 long형으로 자동 형변환되어도 값은 변하지 않는다.

올바른 결과는 변수 a 또는 b의 타입을 long으로 형변환해야 한다.

```java

class Ex3_10 {
	public static void main(String args[]) { 
		long a = 1_000_000 * 1_000_000;
		long b = 1_000_000 * 1_000_000L;

		System.out.println("a="+a);
		System.out.println("b="+b);
	}
}

```

# 11. Math.round()로 반올림하기

반올림을 하려면 Math.round()를 사용하면 된다. 이 메서드는 소수점 첫째 자리에서 반올림한 결과를 정수로 반환한다.

`long result = Math.round(4.52);` -> `5`

소수점 첫째 자리가 아닌 다른 자리에서 반올림 하려면 10의 n제곱으로 적절히 곱하고 나누어야 한다.

```java

class Ex3_11 {
	public static void main(String args[]) { 
		double pi = 3.141592; 
		double shortPi = Math.round(pi * 1000) / 1000.0;
		System.out.println(shortPi);
	}
}

```

위 과정에서 1000.0이 아니라 1000으로 나누었으면 결과는 3.142가 아닌 3이 된다. int와 int의 나눗셈 결과는 int이기 때문이다.

# 12. 나머지 연산자

나머지 연산자는 왼쪽의 피연산자를 오른쪽의 피연산자로 나누고 난 나머지 값을 결과로 반환한다. 나눗셈에서처럼 나누는 수(오른쪽 피연산자)로 0을 사용할 수 없고, 피연산자로 정수와 실수를 허용한다. 나머지 연산자는 주로 짝수, 홀수 또는 배수 검사 등에 주로 사용된다.

```java

class Ex3_12 {
	public static void main(String args[]) { 
		int x = 10;
		int y = 8;

		System.out.printf("%d을 %d로 나누면, %n", x, y); 
		System.out.printf("몫은 %d이고, 나머지는 %d입니다.%n", x / y, x % y); 
	}
}

```

```java

class Ex3_13 { 
	public static void main(String[] args) { 
		System.out.println(-10%8); 
		System.out.println(10%-8); 
		System.out.println(-10%-8); 
	} 
}

```

나머지 연산자(%)는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 결과가 같다.

> 그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.

# 13. 비교 연산자

두 피연산자를 비교하는데 사용되는 연산자다. 주로 조건문과 반복문의 조건식에 사용되며, 연산결과는 오직 true와 false 둘 중의 하나이다.

비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다는 점에 주의하자

## A. 대소비교 연산자 <, >, <=, >=

참이면 true, 거짓이면 false를 결과로 반환한다. 기본형 중에서는 boolean을 제외한 나머지 자료형에 다 사용할 수 있지만 참조형에는 사용할 수 없다.

| 비교연산자 | 연산결과                     |
| ---------- | ---------------------------- |
| >          | 좌변 값이 크면 true          |
| <          | 좌변 값이 작으면 true        |
| >=         | 좌변 값이 크거나 같으면 true |
| <=         | 좌변 값이 작거나 같으면 true |

## B. 등가비교 연산자 \=\=, !=

두 피연산자의 값이 같은지 또는 다른지를 비교하는 연산자이다. 모든 자료형(기본형, 참조형)에 사용할 수 있다. 기본형의 경우 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지(주소값이 같은지)를 알 수 있다.

기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 등가비교 연산자 (\=\=, !=)로 기본형과 참조형을 비교할 수는 없다.

| 비교연산자 | 연산겨로가          |
| ---------- | ------------------- |
| \=\=       | 두 값이 같으면 true |
| !=         | 두 값이 다르면 true |

> `>=`와 같이 두 개의 기호로 이루어진 연산자는 `=>`와 같이 기호의 순서를 바꾸거나 `> =`와 같이 중간에 공백이 들어가서는 안된다.

# 14. 문자열의 비교

두 문자열을 비교할 때는, 비교 연산자 `==`대신 `equals()`라는 메서드를 사용해야 한다. 비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 `equals()`를 사용하는 것이다.

`quals()`는 비교하는 두 문자열이 같으면 true, 다르면 false를 반환한다.

```java

class Ex3_14 {
	public static void main(String[] args) {
		String str1 = "abc";
		String str2 = new String("abc");

		System.out.printf("\"abc\"==\"abc\" ? %b%n", "abc"=="abc");
		System.out.printf(" str1==\"abc\" ? %b%n",    str1=="abc");
		System.out.printf(" str2==\"abc\" ? %b%n",    str2=="abc");
		System.out.printf("str1.equals(\"abc\") ? %b%n", str1.equals("abc"));
		System.out.printf("str2.equals(\"abc\") ? %b%n", str2.equals("abc")); 
		System.out.printf("str2.equals(\"ABC\") ? %b%n", str2.equals("ABC"));
		System.out.printf("str2.equalsIgnoreCase(\"ABC\") ? %b%n", str2.equalsIgnoreCase("ABC"));
	}
}

```

str2와 "abc"의 내용이 같은데도 `==`로 비교하면, false를 결과로 얻는다. 내용은 같지만 서로 다른 객체라서 그렇다. 그러나 equals()는 객체가 달라도 내용이 같으면 true를 반환한다. 그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다.

대소문자를 구별하지 않고 비교하려면 `equalsIgnoreCase()`를 사용하면 된다.

# 15. 논리 연산자 &&, ||

두 개의 조건이 결합된 경우 **논리 연산자**를 사용한다. 논리 연산자는 둘 이상의 조건을 **그리고(AND)** 나 **또는(OR)** 으로 연결하여 하나의 식으로 표현할 수 있게 해준다.

- 논리 연산자 **&&**
	- 그리고(AND)
	- 두 피연산자가 모두 true일 때만 true를 결과로 얻는다.
- ||
	- 또는 (OR)
	- 두 피연산자 중 어느 한 쪽만 true이어도 true를 결과로 얻는다.

논리 연산자는 피연산자로 boolean형 또는 boolean형 값을 결과로 하는 조건식만을 허용한다.

1. x는 10보다 크고, 20보다 작다.

`x > 10 && x < 20`

보통은 변수를 왼쪽에 쓰지만 이런 경우 가독성측면에서 보면 아래의 식이 더 나을 수 있다.

`10 < x && x < 20`


2. i는 2의 배수 또는 3의 배수이다.

`i % 2 == 0 || i % 3 == 0`

3. i는 2의 배수 또는 3의 배수지만 6의 배수는 아니다.

`(i % 2 == 0 || i % 3 == 0) && i % 6 != 0`

괄호를 사용한 이유는 `&&`가 `||`보다 우선순위가 높기 때문이다.

4. 문자 ch는 숫자('0' ~ '9')이다.

`'0' <= ch && ch <= '9'`

```java

import java.util.*;  // Scanner클래스를 사용하기 위해 추가

class Ex3_15 {
	public static void main(String args[]) { 
		Scanner scanner = new Scanner(System.in);
		char ch = ' ';

		System.out.printf("문자를 하나 입력하세요.>");

		String input = scanner.nextLine();
		ch = input.charAt(0);

		if('0' <= ch && ch <= '9') {
			System.out.printf("입력하신 문자는 숫자입니다.%n");
		}

		if(('a' <= ch && ch <= 'z') || ('A'<= ch && ch <= 'Z')) {
			System.out.printf("입력하신 문자는 영문자입니다.%n");
		}
	} // main
}

```

# 16. 논리 부정 연산자 !

피연산자가 true이면 false, false면 true로 결과를 반환한다.

어떤 값에 논리 부정 연산자 `!`를 반복적으로 적용하면 참과 거짓이 차례대로 반복된다.

논리 부정 연산자 `!`가 주로 사용되는 곳은 조건문과 반복문의 조건식이며, 이 연산자를 잘 사용하면 조건식이 보다 이해하기 쉬워진다.

단항 연산자는 결합 방향이 오른쪽에서 왼쪽이다.

# 17. 조건 연산자

조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자 하나뿐이다

`조건식 ? 식1 : 식2`

첫 번째 피연산자인 조건식의 평가결과에 따라 다른 결과를 반환한다. 조건식의 평가결과가 true이면 식1, false이면 식2가 연산결과가 된다.

조건 연산자는 if문으로 바꿔 쓸 수 있다.

조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술변환이 발생한다.

`x = x + (mod < 0.5 ? 0 :0.5)` -> `x = x + (mod < 0.5 ? 0.0 : 0.5)`

```java

class Ex3_17 {
	public static void main(String args[]) { 
		int  x, y, z;
		int  absX, absY, absZ;
		char signX, signY, signZ;

		x = 10;
		y = -5;
		z = 0;

		absX = x >= 0 ? x : -x;  // x의 값이 음수이면, 양수로 만든다.
		absY = y >= 0 ? y : -y;
		absZ = z >= 0 ? z : -z;
		signX = x > 0 ? '+' : ( x==0 ? ' ' : '-');  // 조건 연산자를 중첩
		signY = y > 0 ? '+' : ( y==0 ? ' ' : '-'); 
		signZ = z > 0 ? '+' : ( z==0 ? ' ' : '-'); 

		System.out.printf("x=%c%d%n", signX, absX);
		System.out.printf("y=%c%d%n", signY, absY);
		System.out.printf("z=%c%d%n", signZ, absZ);
		
	}
}

```

# 18. 대입 연산자

변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장한다. 이 연산자는 오른쪽 피연산자의 값을 왼쪽 피연산자에 저장한다. 저장된 값을 연산결과로 반환한다.

대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다. 연산 진행 방향은 오른쪽에서 왼쪽이다.

`x = y = 3` 

## A. lvalue와 rvalue

왼쪽 피연산자 (lvalue (left value))

오른쪽 피연산자 (rvalue (right value))

rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능하다.
lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다. 즉, 리터럴이나 상수같이 값을 저장할 수 없는 것들은 lvalue가 될 수 없다.

# 19. 복합 대입 연산자

대입 연산자는 다른 연산자(op)와 결합하여 `op=`와 같은 방식으로 사용될 수 있다.

| op=          | =                  |
| ------------ | ------------------ |
| i += 3;      | i = i + 3;         |
| -=           |                    |
| \*=          |                    |
| /=           |                    |
| %=           |                    |
| <<=          |                    |
| >>=          |                    |
| &=           |                    |
| ^=           |                    |
| \|=          |                    |
| i \*= 10 + j | i = i \* (10 + j); |

대입 연산자의 우변이 둘 이상의 항으로 이루어져 있는 경우, `i *= 10 + j`를 `i = i * 10 + j`로 오해하지 말자.



# 참고문헌

남궁성, "자바의 정석 - 기초편", 도우출판, 2019년

#자바