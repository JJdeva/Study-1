# Internet

- 응용 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

# ISO/OSI 7계층

- 웅용 계층
- 프리젠테이션 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

---

# 1. 응용 계층의 예

- 예
	- 게임
	- 인터넷 브라우저상의 응용
		- 구글 검색
		- 웹툰
		- 블로그
		- 카페
	- 메일
	- 지도

---

# 2. 네트워크 응용의 구조

## A. Client - Server 구조

> 응용을 서비스해주는 컴퓨터를 따로 두는 구조

- 예
	- 웹 검색

- 장점
	- 서버가 대기하고 있다가 사용자가 접속하면 서비스를 제공해준다.
- 단점
	- 모든 서비스에 서버가 관여할수록 서버에 부하가 높아진다.

서비스가 안정적으로 동작하길 바라면 선택.

## B. Peer - To - Peer (P2P) 구조

- 예
	- 토렌트

## C. 하이브리드 구조

필요시에는 서버와 관리하지만, 클라이언트끼리 연결할 수 있으면, 그냥 연결한다.

- 예
	- skype
	- 스타크래프트

서버에 대한 부하가 분산된다.

# 3. 프로세스간 통신

## A. 프로세스의 종류

- 서버 프로세스
- 클라이언트 프로세스
- 피어 프로세스
	- p2p를 위한 프로세스

---

- 응용
	- 네트워크로 연결된 컴퓨터들이 협력하여 제공하는 서비스
	- 예
		- 구글 검색

		![](/bin/Network_image/network_2_3.png)

- 프로세스
	- 하나의 컴퓨터에서 독립된 메모리공간을 가지고 수행되고 있는 프로그램의 단위

![](/bin/Network_image/network_2_4.png)

## B. 프로세스 주소

- IP 주소 + 포트 번호
- 서로의 포트 번호와 IP 주소를 알면 통신이 가능해진다.

---

-  프로세스의 주소
	-  기계 주소 (IP)
		-  xxx.xxx.xxx.xxx
			-  0 ~ 255
			-  172.31.6.4
			-  256^{4} = 2^{32} = 약 40억
	- 포트번호
		- 2^32개
		- 2^16개 - TCP
		- 2^16개 - UDP
		
		![](/bin/Network_image/network_2_5.png)
		
## C. 소켓 통신

- TCP의 경우
	- 소켓
	- 서버소켓

---

- 응용 계층을 위한 API
	- 전송 계층과 세션 계층을 연결해주는 인터페이스

매번 IP주소와 포트번호를 적어서 패킷을 전송해야한다.

다만, 매번 새로 패킷을 만들어서 데이터를 전송하면 IP나 포트번호를 잘못 입력할 가능성이 있어서 클라이언트와 웹 서버 사이에 Private Channel을 만들어서 이를 이용해서 통신한다.

이것을 Socket이라고 한다.

예를 들어, A 클라이언트와 B 클라이언트가 웹 서버에 접속한다면, 각 클라이언트에게 패킷을 보낼때 IP와 포트번호를 구분해서 보내야하는데, 

소켓을 만든다면, 소켓 객체를 통해서 통신을 할 수 있다.

- 좋은점
	- 일일히 편지봉투 내용(IP주소와 포트번호)를 기억할 필요 없이 통신이 가능해진다.

### a. 코드

```python

import socket

clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
clientSocket.connect(("127.0.0.1", 9999))

clientSocket.send("Hello, Server")

str = clientSocket.recv(100)
print(str)

clientSocket.close()

```

```python

import socket

serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serverSocket.bind(("", 9999))
serverSocket.listen(1)

(sock, addr) = serverSocket.accept()

sock.send("Hello, Client")

str = sock.recv(100)
print(str)

sock.close()
serverSocket.close()

```

---

# 전송 계층

## A. 인터넷 전송계층의 서비스

### a. TCP

- 연결기반 전송 계층
	- 두개의 프로세스들을 연결하고나서 통신한다.
- 연결에 대한 관리
	- 데이터 유실을 복구한다.
		- 중간에 스위치가 죽거나, 잡음으로 인해 데이터가 깨지는 등의 이유로 데이터 유실이 발생한다.
		- 한번 보낸 패킷은 반드시 목적지에 도달한다고 생각 할 수 있다.
- 데이터 순서를 보장한다.
- 혼잡에 민감하게 패킷전송률을 조정한다.
	- 패킷이 많이 유실된다면(네트워크가 혼잡하다면), 네트워크가 덜 혼잡해질때까지 패킷을 쌓아놓고 천천히 보낸다.
	- 속도가 느림

![](/bin/Network_image/network_2_6.png)

### b. UDP

- 무연결 전송 계층
	- 소켓을 열지만, 두 프로세스 사이에 연결 선이 없다.
	- 연결이 없으니, 데이터를 아무곳에나 던진다. 
	- 연결을 만들지 않고, 매 패킷마다 받는 사람의 주소를 써서 보낸다.
- 관리가 어렵다.
	- 데이터가 유실될 수 있다.
- 데이터 순서가 역전될 수 있다.
- 최대 성능으로 패킷전송
	- 속도가 빠름
	- 실시간성이 중요한 통신에 사용

![](/bin/Network_image/network_2_7.png)

# 세션 계층

FTP, HTTP

역사적으로 FTP가 먼저 나옴. 현재 주로 사용하는건 HTTP

## A. FTP (File Transfer Protocol)

![](/bin/Network_image/network_2_8.png)

### a. 목적

원격 host에 있는 파일을 가져오거나 파일을 보내기(업로드)위한 프로토콜

### b. 특징

- 세션 로그인과 종료가 존재한다.
- 로그인을 통해 권한획득
- 로그인 정보를 서버가 관리
- stateful protocol
	- 클라이언트가 서버에 로그인하고 그 안에서 필요한 작업을 하고 로그아웃할때까지 서버가 모든 정보를 관리한다.
	- 사용자의 상태정보를 서버가 이용한다.
		- 로그인을 했다
		- 어떤 파일을 전송하고 있다. 등
	- 서버가 굉장히 많은 상태를 관리하면 사용자가 새로운 기능을 요구할때, 그 기능에 대해서 서버가 또 관리해야한다. 관리할게 늘어나면, 프로토콜을 다시 수정해야한다.
		- 세션 계층을 수정해야하기 때문에 확장이 힘듬
- 상태 관리를 세션 계층에서 해줌.
	- 세션 계층이 많은 일을 함.

## B. HTTP

- www를 위한 세션 계층 프로토콜
- HTML을 기본 프레젠테이션 계층으로 사용.

### a. 목적

전세계 인터넷에 있는 정보를 탐색하는 것

### c. 발명 (만들어진 계기)

Tim Berners-Lee가 CERN에서 1980년대 말 ~ 1990년대 초에 만듬.

### b. 동작

- Web 자료를 가져와서(GET) 보여주기.
- Web 에 자료를 Posting하기. (POST)

1. URL 입력
2. client가 web server에 요청(GET)
3. web server가 client에게 응답

---

![](/bin/Network_image/network_3_1.png)

이 프로토콜은 TCP를 기반으로 한다.

TCP는 연결이 존재하는 프로토콜이기 때문에, 사용자가 URL을 입력하면 TCP 연결을 위한 동작이 GET 요청 앞에 들어가야한다.

연결은 client가 server한테 한다. server는 서버 소켓을 열어두고 client는 열려있는 서버 소켓으로 TCP 연결을 한다.

server의 IP(host name), port(80번)을 통해서 web server 프로세스에 접근한다.

연결이 이루어지면, 연결을 통해서 get / post 요청을 한다.

---

응답이 끝나면 TCP 연결을 종료한다.

---

- stateless protocol
	- 한번 요청이 들어오고 거기에 대한 응답을 하면, 클라이언트에 대한 정보를 잃어버린다.
	- 단순함
		- 요청이 오고 응답을 하면 서버는 자신의 역할을 다 한 것
		- 추가적으로 클라이언트에 대한 정보를 서버가 내부적으로 가지고 있을 필요는 없다.


### d. URL (Universal Resource Locator)

> Web Server의 특정 프로세스에 접근하기 위해서는 IP주소와 Port번호를 알아야 한다.
> > 호스트 이름을 통해서 IP를 추적할 수 있다.
> > 포트번호를 따로 입력하지 않으면, 프로토콜의 약속된 포트번호를 사용한다.

---

예) http://formal.kau.ac.kr/comnet/

1. http:
	- 프로토콜 이름
		- 이 리소스를 이용하고자 할때, 사용하는 세션 layer의 프로토콜 이름
		- 프로토콜 이름이 바뀌면 resource locator의 뒷부분도 다 바뀐다.
2. //formal.kau.ac.kr
	- //
		- url의 시작을 의미
	- formal.kau.ac.kr
		- 호스트 이름
		- IP주소를 사람이 기억하기 쉽게 표현
		- 큰 개념은 뒤에 있음.
			- kr이 맨 뒤에 있는 것처럼.
3. /comnet/
	- 호스트 안에서 실제로 자원이 존재하는 위치
	- 최상위 디렉토리 밑에 있는 comnet 디렉토리를 가져온다.
		- comnet 뒤에 /가 있어서 디렉토리를 의미함.

예2) http://formal.kau.ac.kr:8080/

2. /formal.kau.ac.kr:8080
	- 호스트 이름\[:포트번호\]
		- 포트번호는 생략할 수 있다.
		- 1번에 http를 사용하는데, 이는 기본적으로 80번 포트를 사용하기 때문.
3. /
	- root 디렉토리

### e. GET 요청

![](/bin/Network_image/network_3_2.png)

- 원하는 자원을 가져오는 목적
- 형식
	- 헤더
		- 첫 줄에는 내가 무엇을 할지 선언
		- 그 뒤에 매개변수를 통해 좀 더 자세한 정보를 전달
		- 헤더를 통해 내 정보를 전달한다.
			- 나는 어떤 파일을 받을 수 있다.
	- 헤더 다음에 한줄 띄움으로 요청을 끝냄

	![](/bin/Network_image/network_3_3.png)
	
![](/bin/Network_image/network_3_4.png)

![](/bin/Network_image/network_3_5.png)

![](/bin/Network_image/network_3_6.png)

이미지 파일을 따로 GET 요청

![](/bin/Network_image/network_3_7.png)

![](/bin/Network_image/network_3_8.png)

### b. POST 요청

- 자원을 서버에 게시하고 싶을 때
	- 게시판에 글올리기
	- 사진 올리기
	- 웹 브라우저를 이용해 e-mail 보내기
	- 로그인할때
- 헤더 + 바디
- 바디
	- 여러개의 자원(제목, 내용 등)을 합쳐서 하나의 POST로 보낸다.

![](/bin/Network_image/network_3_9.png)

![](/bin/Network_image/network_3_10.png)

![](/bin/Network_image/network_3_11.png)

![](/bin/Network_image/network_3_12.png)

- 내용이 긴 경우
	- 사진이나 이메일 등의 보내고자 하는 내용이 길면 GET으로 보내기 힘들다.

- 숨기고 싶은 내용
	- URL에 내용들이 평문으로 보여지기 때문에 보안이 취약하다.


---

- GET
	> GET /comnet/ HTTP/1.1
	> > GET / URL 뒤에 있는 컴퓨터 안에 있는 자원 / HTTP 버전번호
	> Host: ~
	> > 기타 매개변수 정보

	- 헤더 뒤에 한줄 띄우면 GET 요청은 끝난다.


- POST
	- 헤더부분은 GET과 똑같음.
		- GET이 아닌 POST인 것만 다름
	- 헤더 뒤에 한줄 띄고 바디를 넣는다.
	- 바디에는 보내고자하는 내용을 넣는다.
	- 바디 내용이 짧을 경우 POST대신 GET으로 보내면서 URL 뒤에 바디 내용을 파라미터로 붙인다. (그럼 URI가 됨)
		- /comnet?id=kau&pw=kau&action=login

- URI (Universal resource Identifier)
	- 정보
	- URL 뒤에(? 뒤에) 인자가 있음
- URL
	- 위치
	- URL 뒤에(? 뒤에) 인자가 없음

어떤 형태의 HTTP Request한다고 하더라도, Response 형태는 동일하다. `HTTP/1.1 200 OK`

---
---
---

- HTTP
	- 단순한 프로토콜
	- stateless
		- 한번 요청을 해서 응답을 받으면, 서버쪽에 있는 세션 레이어에서는 그 다음 요청이 들어왔다고 하더라도 앞에 어떤 요청을 했는지에 대해서 기억하지 않는다.

# Cookie (쿠키)

## A. 웹 응용의 구조

- 웹 클라이언트
	- HTML 엔진을 가지고 있음.
	![](/bin/Network_image/network_3_13.png)
- 웹 서버
	- stateless는 세션 계층(HTTP)에만 적용되고, 서버 응용(응용 계층)은 stateless가 아님.
	- HTTP (세션 계층)
		- 바둑판, 바둑알, 규칙
	- 서버응용 (응용 계층)
		- 바둑을 두는 사람
	- 밑에 있는 Layer들(세션 계층)이 서버 응용이 여러가지 일을 할 수 있는 자유도를 주기 때문에 여러가지 서비스를 즐길 수 있다.

![](/bin/Network_image/network_3_14.png)

- 쿠키
	- 서버 응용이 이전에 접근한 사람이 다시 왔는지를 구별하기 위해 쿠키를 사용한다.
	- 쿠키는 상태정보를 담는 도구이다.

## B. 쿠키란?	

- 서버응용이 클라이언트의 이전 작업정보(state)를 파악하기 위한 도구
- 서버는 상태 정보를 가지고 있지 않지만, 클라이언트가 상태 정보를 가지고 있는 것. 그게 쿠키
- 클라이언트가 쿠키를 서버에게 보여주면 서버는 내가 누구인지 기억해낼 수 있다.

![](/bin/Network_image/network_3_15.png)

## C. 프로토콜

- HTTP Response 헤더 (서버 -> 클라이언트)
	- Set-cookie라는 필드가 있음.
- HTTP Request 헤더 (클라이언트 -> 서버)
	- Cookie라는 필드가 있음.

![](/bin/Network_image/network_3_16.png)

![](/bin/Network_image/network_3_17.png)

![](/bin/Network_image/network_3_18.png)

---

![](/bin/Network_image/network_3_19.png)

![](/bin/Network_image/network_3_20.png)

![](/bin/Network_image/network_3_21.png)

---

응용 계층에서 이런 쿠키들이 왔다갔다 하고 세션 계층에서는 그 정보를 이용하지 않는다. 쿠키를 응용 계층으로 던져줄 뿐이다.

## c. 방법론

기억해야할 사항을 쿠키에 담아 클라이언트가 기억하도록하고 서버는 클라이언트의 방문시 주는 쿠키 정보에 맞추어 반영한다.

## b. 문제

- 클라이언트에게 너무 많은 권한과 정보를 준다.
	- 해결책
		- 이 문제를 해결하는 방법이 세션

## B. 세션

- 클라이언트에게 세션 ID 정보만 쿠키로 전달하고 세션들의 특성은 서버가 관리한다.

- 예
	- 몇 번 방문했는지?
		- 쿠키
			- 클라이언트에 저장
		- 세션
			- 서버에 저장

![](/bin/Network_image/network_3_22.png)

![](/bin/Network_image/network_3_23.png)

Set-Cookie에 쿠키가 아닌, session id를 준다.

![](/bin/Network_image/network_3_24.png)

![](/bin/Network_image/network_3_25.png)

쿠키는 기억해야할 정보를 클라이언트에게 주고 클라이언트가 그 정보를 서버에게 주면 그 정보를 이용하여 내용을 가공해서 응답을 한다.

세션은 클라이언트에게 세션 ID만 주고, 다음에 올때 세션 ID를 서버에게 넘기면, 클라이언트가 준 ID 정보를 가지고 서버에 저장된 기록을 찾아서 가공하고 응답한다.

- 요즘은, 악용될만한 정보들은 모두 세션으로 관리한다.

---

# HTTP 성능

## A. HTTP Transaction의 성능 향상

### a. 기본 HTTP

![](/bin/Network_image/network_3_26.png)

### b. Persistent HTTP

서버가 응답을 보내고 바로 TCP 종결을 하지 않고 기다림

![](/bin/Network_image/network_3_27.png)

시간초 비교


### c. Pipelined HTTP

![](/bin/Network_image/network_3_28.png)

#### ㄱ) 성능

##### 지연시간

- 패킷을 보내기 시작한 시점에서 패킷을 받기 시작한 시점까지 걸리는 전송 지연 시간

- 클라이언트에서 서버까지 (양 단말 간의 지연 시간)
	- 100ms

![](/bin/Network_image/network_3_29.png)

##### 전송률

단위시간(초)당 전송되는 데이터의 양

예) 끝단간 지연시간이 100ms이고 전송률이 100MB/s인 네트워크에서 1MB를 전송하여 수신을 완료하는데 걸리는 시간은?

![](/bin/Network_image/network_3_30.png)

### persistent HTTP vs pipelined HTTP 성능 비교

#### 성능

1. 끝단간 지연시간
	- 100ms
2. 전송률
	- 100KB/s
3. 전송받고자하는 정보
	- HTML 페이지
		- 문서, 이미지 3개
	- HTML 문서
		- 1KB
	- 이미지당 크기
		- 10KB
4. HTTP 헤더
	- Request
		- 1KB
	- Response
		- 1KB
5. TCP connection 연결 / 종결 시간
	- 연결
		- 400ms
	- 종결
		- 200ms

#### 기본 HTTP

![](/bin/Network_image/network_3_31.png)

#### persistent HTTP

TCP를 맺고 끝는 600ms가 아껴짐

![](/bin/Network_image/network_3_32.png)


#### pipelined HTTP

![](/bin/Network_image/network_3_33.png)

----

# HTTP
## 성능향상 (다중 Transaction)
### Persistent HTTP
### Pipelined HTTP
## 성능향상 (네트워크 구조)
### Web Cache (Proxy Server)
ISP (Internet Service Provider)

많은 사용자가 요청할 것이라 생각되는 요청을 ISP(KT, 등의 통신사)가 가지고 있는 별도의 Web cache에 저장한다.

그리고 다른 사용자가 동일한 요청을 했을 때, Web cache에 있는 내용을 전달하여, 해외 ISP에 통신하는 비용(속도, 비용)을 절약한다.

---

- ISP에서 비용절감을 위하여 이전에 가져온적이 있는 문서(데이터)를 DB에 임시저장하고 동일 문서(데이터)가 다시 요청될 때 재사용. 
	- 동일 문서를 요청하는 클라이언트는 다른 클라이언트일 수도 있고 같은 클라이언트일 수도 있음

- 웹 캐시는 서버이자 클라이언트 역할을 한다.
	- 서버 입장에서는 웹 캐시가 클라이언트 역할
	- 사용자 입장에서는 서버 역할
	- 중간상인

- Web Cache는 중개상인의 개념
	- Server이자 Client 역할

#### Web Cache가 주는 이득

- 소비자가 얻는 이득
	- 요청에 대한 응답시간단축
- ISP가 얻는 이득
	- 제공하는 교통량 증가
		- 더 많은 사용자 수용
- 서버(웹 서버)가 얻는 이득
	- 더 적은 서버 용량으로 더 많은 사용자를 지원할 수 있음

#### 예시

![](/bin/Network_image/network_3_34.png)

바뀐적이 있다면, 일반적인 과정과 동일

![](/bin/Network_image/network_3_35.png)

![](/bin/Network_image/network_3_36.png)

# 참고문헌

[[Web 통신] web 통신 과정(GET과 POST의 패킷 분석) (tistory.com)](https://c-i-s.tistory.com/entry/Web-%ED%86%B5%EC%8B%A0-web-%ED%86%B5%EC%8B%A0-%EA%B3%BC%EC%A0%95GET%EA%B3%BC-POST%EC%9D%98-%ED%8C%A8%ED%82%B7-%EB%B6%84%EC%84%9D)

