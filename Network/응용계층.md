# Internet

- 응용 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

# ISO/OSI 7계층

- 웅용 계층
- 프리젠테이션 계층
- 세션 계층
- 전송 계층
- 네트워크 계층
- 데이터 링크 계층
- 물리 계층

---

# 1. 응용 계층의 예

- 예
	- 게임
	- 인터넷 브라우저상의 응용
		- 구글 검색
		- 웹툰
		- 블로그
		- 카페
	- 메일
	- 지도

---

# 2. 네트워크 응용의 구조

## A. Client - Server 구조

> 응용을 서비스해주는 컴퓨터를 따로 두는 구조

- 예
	- 웹 검색

- 장점
	- 서버가 대기하고 있다가 사용자가 접속하면 서비스를 제공해준다.
- 단점
	- 모든 서비스에 서버가 관여할수록 서버에 부하가 높아진다.

서비스가 안정적으로 동작하길 바라면 선택.

## B. Peer - To - Peer (P2P) 구조

- 예
	- 토렌트

## C. 하이브리드 구조

필요시에는 서버와 관리하지만, 클라이언트끼리 연결할 수 있으면, 그냥 연결한다.

- 예
	- skype
	- 스타크래프트

서버에 대한 부하가 분산된다.

# 3. 프로세스간 통신

## A. 프로세스의 종류

- 서버 프로세스
- 클라이언트 프로세스
- 피어 프로세스
	- p2p를 위한 프로세스

---

- 응용
	- 네트워크로 연결된 컴퓨터들이 협력하여 제공하는 서비스
	- 예
		- 구글 검색

		![](/bin/Network_image/network_2_3.png)

- 프로세스
	- 하나의 컴퓨터에서 독립된 메모리공간을 가지고 수행되고 있는 프로그램의 단위

![](/bin/Network_image/network_2_4.png)

## B. 프로세스 주소

- IP 주소 + 포트 번호
- 서로의 포트 번호와 IP 주소를 알면 통신이 가능해진다.

---

-  프로세스의 주소
	-  기계 주소 (IP)
		-  xxx.xxx.xxx.xxx
			-  0 ~ 255
			-  172.31.6.4
			-  256^{4} = 2^{32} = 약 40억
	- 포트번호
		- 2^32개
		- 2^16개 - TCP
		- 2^16개 - UDP
		
		![](/bin/Network_image/network_2_5.png)
		
## C. 소켓 통신

- TCP의 경우
	- 소켓
	- 서버소켓

---

- 응용 계층을 위한 API
	- 전송 계층과 세션 계층을 연결해주는 인터페이스

매번 IP주소와 포트번호를 적어서 패킷을 전송해야한다.

다만, 매번 새로 패킷을 만들어서 데이터를 전송하면 IP나 포트번호를 잘못 입력할 가능성이 있어서 클라이언트와 웹 서버 사이에 Private Channel을 만들어서 이를 이용해서 통신한다.

이것을 Socket이라고 한다.

예를 들어, A 클라이언트와 B 클라이언트가 웹 서버에 접속한다면, 각 클라이언트에게 패킷을 보낼때 IP와 포트번호를 구분해서 보내야하는데, 

소켓을 만든다면, 소켓 객체를 통해서 통신을 할 수 있다.

- 좋은점
	- 일일히 편지봉투 내용(IP주소와 포트번호)를 기억할 필요 없이 통신이 가능해진다.

### a. 코드

```python

import socket

clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
clientSocket.connect(("127.0.0.1", 9999))

clientSocket.send("Hello, Server")

str = clientSocket.recv(100)
print(str)

clientSocket.close()

```

```python

import socket

serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
serverSocket.bind(("", 9999))
serverSocket.listen(1)

(sock, addr) = serverSocket.accept()

sock.send("Hello, Client")

str = sock.recv(100)
print(str)

sock.close()
serverSocket.close()

```

---

# 전송 계층

## A. 인터넷 전송계층의 서비스

### a. TCP

- 연결기반 전송 계층
	- 두개의 프로세스들을 연결하고나서 통신한다.
- 연결에 대한 관리
	- 데이터 유실을 복구한다.
		- 중간에 스위치가 죽거나, 잡음으로 인해 데이터가 깨지는 등의 이유로 데이터 유실이 발생한다.
		- 한번 보낸 패킷은 반드시 목적지에 도달한다고 생각 할 수 있다.
- 데이터 순서를 보장한다.
- 혼잡에 민감하게 패킷전송률을 조정한다.
	- 패킷이 많이 유실된다면(네트워크가 혼잡하다면), 네트워크가 덜 혼잡해질때까지 패킷을 쌓아놓고 천천히 보낸다.
	- 속도가 느림

![](/bin/Network_image/network_2_6.png)

### b. UDP

- 무연결 전송 계층
	- 소켓을 열지만, 두 프로세스 사이에 연결 선이 없다.
	- 연결이 없으니, 데이터를 아무곳에나 던진다. 
	- 연결을 만들지 않고, 매 패킷마다 받는 사람의 주소를 써서 보낸다.
- 관리가 어렵다.
	- 데이터가 유실될 수 있다.
- 데이터 순서가 역전될 수 있다.
- 최대 성능으로 패킷전송
	- 속도가 빠름
	- 실시간성이 중요한 통신에 사용

![](/bin/Network_image/network_2_7.png)

# 세션 계층

FTP, HTTP

역사적으로 FTP가 먼저 나옴. 현재 주로 사용하는건 HTTP

## A. FTP (File Transfer Protocol)

![](/bin/Network_image/network_2_8.png)

### a. 목적

원격 host에 있는 파일을 가져오거나 파일을 보내기(업로드)위한 프로토콜

### b. 특징

- 세션 로그인과 종료가 존재한다.
- 로그인을 통해 권한획득
- 로그인 정보를 서버가 관리
- stateful protocol
	- 클라이언트가 서버에 로그인하고 그 안에서 필요한 작업을 하고 로그아웃할때까지 서버가 모든 정보를 관리한다.
	- 사용자의 상태정보를 서버가 이용한다.
		- 로그인을 했다
		- 어떤 파일을 전송하고 있다. 등
	- 서버가 굉장히 많은 상태를 관리하면 사용자가 새로운 기능을 요구할때, 그 기능에 대해서 서버가 또 관리해야한다. 관리할게 늘어나면, 프로토콜을 다시 수정해야한다.
		- 세션 계층을 수정해야하기 때문에 확장이 힘듬
- 상태 관리를 세션 계층에서 해줌.
	- 세션 계층이 많은 일을 함.

## B. HTTP

