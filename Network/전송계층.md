# 전송계층

> 어떻게 두 단말(end-to-end) 사이에서 신뢰성있는 커뮤니케이션을 할지에 관한 내용이 전송 계층의 주된 내용.

- Reliable Networking (End-to-End)
	- 성능향상 (pipelining)

---

- reliable network를 구현하는 기본적인 방법
	- sequence number를 보낸다.
		- 패킷에 번호를 붙인다.
	- acknowledgement 패킷
		- 잘 받았다는 패킷이 필요하다.
	- time out
		- ack 패킷이 안오면, 패킷을 다시 보내야한다.
		- 각 패킷마다 ack이 오는지를 판독하는 타이머를 통해 ack 패킷이 안왔다는 것을 확인한다.

---

TCP에서 reliable network

![[Pasted image 20220204111931.png]]

1. 무한한 흐름 X
	1. 패킷화를 하여 쪼갠다.
2. 패킷 유실
	1. ack 패킷을 보내서, 패킷이 잘 도착했는지 확인한다.
	2. ack 패킷이 도착하지 않으면, 재전송한다.

	=> 1. A가 패킷을 보내는 과정에서 유실되는 경우
		2. B가 ack 패킷을 보내는데 패킷이 유실되는 경우
		3. B가 ack 패킷을 보냈는데, delay가 심해서 A쪽의 타이머에 타임아웃이 걸려서 패킷이 유실되었다고 생각하는 경우

		![[Pasted image 20220204113214.png]]

![[Pasted image 20220204113129.png]]

패킷 넘버에 몇 바이트를 할당할지를 결정해야한다.

패킷의 순서가 바뀌지 않는다면, 1비트로도 가능하다.

3. 패킷 순서가 바뀔 수 있다.


4. 패킷이 변조될 수 있다.

![[Pasted image 20220204113651.png]]

# 어떻게 성능을 향상시킬까

네트워크의 성능을 측정하는 2가지 요소

1. 전송율
2. 지연시간

# pipelining

- 병렬성을 가진다.

---

- 연속된 대량의 작업이 순차성을 갖고 있으나 앞의 일이 종료하지 않고도 다음 일을 시작할 수 있는 병렬성을 가진 경우의 성능향상 기법

![[Pasted image 20220204114259.png]]

1번이 도착하기 전에, 2번을 전송하고, 2번이 도착하기 전에 3번을 전송함

---

각각의 패킷들이 잘 도착한 것과 전송하는 것은 독립적임.
1번 패킷이 잘 도착하는 것과 2번 패킷을 전송하는 것은 독립적인 것처럼.

![[Pasted image 20220204114622.png]]

## pipelining 구현 방법

### 1. Go-back-N

- 최대 N개의 패킷을  병렬적으로 처리하는 내용
- 송신측에서는 N개의 packet을 buffering한다. (재전송하기 위해서)
- 수신측에서는 **순차적**으로 잘 수신된 packet에 대하여 Ack을 송신하고 packet의 내용(payload, 실제 전송하고자 하는 내용)을 응용계층으로 올려보낸다.
- 송신측에서는 buffer의 여유가 생기면(ack을 받아서), 그만큼 추가로 pipelining한다.
	- ack을 받으면 해당 ack 패킷의 번호는 buffer에서 버린다.(지운다)
	- 그리고 빈 buffer에 새로운 packet을 추가해서 pipelining을 한다.

![[Pasted image 20220204135919.png]]

#### buffering의 의미

- 수신이 확실하지 않은 packet을 재전송하기 위해 보관

#### 장점

2번 패킷에 대한 ack을 받지 못했지만, 받은 것과 동일하게 
패킷이 유실되었지만, 효용이 살아있다

중간에 패킷이 유실(2번 패킷의 ack)되어도 다음 패킷(3번 패킷의 ack)을 통해, 2번 패킷을 받은 것과 동일하게 처리할 수 있다.

---

- 단순하다.
	- 특히 수신측이 단순하다.
- 간명하게 시스템의 상태가 추상화된다.

#### 단점

- 수신측에서 순서에 맞지 않는(이빨이 빠진) packet이 온 경우의 반응
	1. 조용히 있는다. (아무것도 못받은 것처럼)
	2. 잘 받은 마지막 packet에 대한 ack을 전송한다.
		1. ![[Pasted image 20220204120933.png]]
- Go-back-N에서의 재전송 정책
	- 각 packet 전송시에 packet을 위한 timer를 설정
		- timer는 ack을 받으면, ack에 해당하는 packet과 앞쪽 packet에 대한 timer를 소멸한다.
	- Timer 이벤트 발생시(timer가 종료될때까지 ack packet을 받지 못함) 해당 packet부터 재전송한다.
	- ![[Pasted image 20220204121822.png]]
	#### 추가 재전송 정책
	
	- k번째 packet에 대한 ack이 반복적으로 오는 경우 k+1번째 packet의 유실을 함축(의미)하게 된다.
	- n번정도 k패킷에 대한 ack이 오면 timer와 무관하게 k+1번째 packet부터 재전송한다.

![[Pasted image 20220204122142.png]]

---

- 패킷 유실에 대한 복구 비용이 많이 든다.

### 2. Selective Repeat

수신측에 buffer를 사용한다.

![[Pasted image 20220204135755.png]]

- Go-back-N의 단점을 보완하였다.
- 수신측에 버퍼를 둔다.
	- 빠진 packet이 있을 경우 그 뒤쪽의 잘 도착한 packet들은 버퍼에 보관한다.
	- 빠진 packet이 추후 도착하면, buffer에 저장한 이후 packet들까지 순차적으로 [[Application Layer]]에 전달한다.

![[Pasted image 20220204141700.png]]

#### 장점

- 실패한 packet만 재전송한다.
	- 성능이 향상된다.

#### 단점

- 시스템 추상화가 복잡해진다.
- 수신측에도 버퍼가 필요하다.

---

위는 신뢰성 있는 전송

---

# TCP vs UDP

- TCP (신뢰도가 중요한 [[Application Layer]]에 사용한다.)
	- 신뢰성 제공
		- 내용 유실 x
			- 순서를 보장한다.
		- 내용상의 이빠짐 x
			- ![[Pasted image 20220204144515.png]]
			- 상대방이 중간에 있는 5번 패킷은 못받고 6번 패킷을 받았다고 하더라도, 6번 패킷을 안받은 것처럼 행동하면, 이빠짐은 없다.
			- 1,2,3,4가 차례대로 오고 네트워크가 끊겼다.라고 전달한다.
			- 순차적인 내용은 다 전달하고, 이빠진 내용 이후는 전달하지 않는다.
				- 연속성을 제공한다.
		- 신뢰성은 양 끝단에서 제공한다.
	- 속도
		- 고의적인 지연이 존재한다.
			- 패킷 수신 순서로 인해 패킷을 수신하였음에도 불구하고 패킷을 수신하였다고 하지 않는 것.
			- 내부적으로 혼잡제어 (Congestion Control)가 존재한다.
				- 네트워크가 혼잡하다면, 패킷을 보낼 수 있어도 기다렸다 보내면서 혼잡 수준을 제어한다.
	- 전송단위
		- 바이트 (Byte)
			- 패킷이 유실되지 않기 때문에 굳이 전송단위를 기억하지 않는다.
		- send() 함수에서 보낸 데이터의 내용과 receive() 함수에서 한번에 받는 데이터 내용 간에 단위 상의 일치 관계가 성립되지 않는다.
	- ![[Pasted image 20220204152555.png]]
- UDP (속도가 중요한 [[Application Layer]]에 사용한다.)
	- 신뢰성 제공
		- 내용 유실 o
	- 속도
		- 고의적 지연은 존재하지 않는다.
			- 1,2,3,4번 packet이 도착하고 5번 packet 없이 6번 packet만 도착하더라도 [[Application Layer]]에 전달해준다.
	- 네트워크가 혼잡하더라도 패킷을 보낸다.
		- 네트워크가 너무 혼잡해진다면, 일부 패킷을 버리게 되어 유실이 발생한다.
	- 전송단위
		- 패킷 (데이터그램)
			- 내용이 유실될 수 있다.
			- 내용이 유실되는 단위를 의미적 단위로만 유실될 수 있다고 이야기한다.
		- send() 함수 호출 단위
			- send() 함수에서 보낸 데이터의 내용과 receive() 함수에서 받는 데이터 내용이 서로 대응 관계가 성립한다.
	- ![[Pasted image 20220204152231.png]]

전송계층은 end-to-end 프로토콜이다. 전송계층은 중간 단계(네트워크 장비들)은 간섭하지 않는다. 양 끝단에 있는 장비에만 간섭한다.

비서같은 역할, 실제로 서비스를 제공하고 받는 부분에만 비서가 존재한다.

전송계층에서 이야기하는 모든 서비스는 양 끝단 해당하는 서비스이다.

# TCP

- Reliable network (reliable community)
	- 신뢰성있게 통신을 한다.
	- 패킷이 내용의 유실도 없고, 순서가 바뀌지도 않는다.
- 내용 변조 탐지
	- 잡음, 기계적인 결함으로 내용이 변하는 것, 간섭(interference)
	- TCP/UDP에 존재한다.
- 혼잡제어
	- 네트워크가 혼잡이 심하면, 패킷을 보내지 않고 기다렸다가 패킷을 보내서 혼잡 수준을 낮춤.
- 흐름제어
	- 
- 포트(사서함)개념 지원
	- 응용을 구분한다.

---

양 끝단만 고려함.

![[Pasted image 20220204155651.png]]

계층이 내려갈때마다 헤더가 하나씩 붙고, 계층이 올라갈때마다 헤더가 하나씩 제거되면서 원래 내용을 보여준다.

---

TCP 헤더는 바이너리 형태로 되어 있음.

32bit으로 끊어서 생각한다.

- 16bit의 src port 번호 / 16bit의 dest port 번호
	- 포트([[Application Layer|응용]])을 구분하고, 거기에 들어가는 각각의 요청에 대한 소켓을 구분하기 위한 용도로 사용하는 것이 TCP의 포트번호임.
- Seq \#, Ack \#
	- Reliable network와 관련됨.
	- TCP에는 seq \#와 ack \#가 같은 패킷에 들어가있음.
	- 패킷에 대한 번호가 아니라, Byte에 대한 번호 (몇번째 Byte인가?에 해당하는 Byte번호)
		- 패킷마다 번호를 붙이는 것이 아닌, Byte마다 번호를 붙임.
- 헤더 길이 정보 / flag / receive window 정보 (16bit)
	- 헤더 길이 정보
	- flag
	- receive window
		- 수신 가능한 버퍼 크기
			- receive window의 크기가 크다면(65536)
				- 버퍼가 아주 크게 있으니까, 마음껏 보내라는 의미
			- receive window의 크기가 0이라면
				- 더 이상 받을 수 없으니 그만보내라고 송신쪽에 말하는 것.
				- 송신쪽에서 데이터를 보내도 내쪽에서는 받을 수 없음.
		- ![[Pasted image 20220204171732.png]]
			- 송신측은 send() 함수를 호출하여 전송계층으로 데이터를 내려보낸다.
			- 전송계층은 네트워크를 통해서 데이터를 반대쪽 전송계층에 보낸다.
			- 반대쪽 전송계층은 받은 데이터를 자신의 buffer안에 쌓아두게 된다.
			- 응용계층이 receive() 함수를 호출하면 buffer에 있는 데이터를 응용계층으로 올려보낸다.
			#### 그런데 문제는
			- 송신측에서 계속 send() 함수로 많은 데이터를 보내는데, 수신측에서는 receive() 함수를 보내지 않는다고 할때, 전송계층에서는 응용계층한테 receive()해달라고 이야기할 수는 없음.
				- 운영체제의 고전적인 특징
					- 패킷이 왔을때, 위쪽 계층에서 아래쪽 계층에 요청하기 전에, 아래쪽 계층에서 위쪽 계층에게 패킷을 보내주는 경우는 굉장히 드물다.
			- 전송계층은 패킷을 buffer에 쌓아두게 된다. (receive() 함수를 부르기 전까지)
			- 수신측의 buffer가 꽉 차면.
				- 송신측에서 패킷을 더 보내봤자 그 패킷은 버려질수밖에 없음.
				- 그렇기에 buffer에 공간이 부족한데도 패킷을 계속 보내게되면 네트워크가 낭비되게 된다.
				- 이를 막기 위해 receive window 필드가 존재한다.
				- 수신측에 데이터를 보내지 못하기 때문에 송신측에서는 응용계층에서 보내라는 데이터를 전송계층에서 자신의(송신측)  buffer에 데이터를 쌓게 된다.
					- 송신측의 buffer도 꽉차면.
						- 응용계층이 추가적으로 데이터를 보내라고 하면, 에러를 반환하여 응용계층에서 더 이상 데이터를 보내지 않도록 조치한다.
		- 흐름제어와 관련됨.
- checksum
	- 내용 변조 탐지
- payload
	- 실제 의미를 갖는 내용

---



---

- 패킷
	- 그 자체로서 단위가 의미있는 내용의 덩어리
	- 그 자체로서 특정한 의미를 갖는 단위
	- 단위로서 가치를 갖을 때, 패킷이라고 한다.
- 세그먼트 (조각)
	- 단위로서 가치를 갖지 않는 개념을 세그먼트라고 한다.
	- TCP는 세그먼트라고 부른다.


## 소켓 vs 포트

소켓 여러개가 하나의 포트에 연결될 수 있음.

![[Pasted image 20220204160654.png]]

하나의 웹 서버에 여러개의 클라이언트가 연결되는 것처럼.

### a. 예제

![[Pasted image 20220204163428.png]]

## seq \#, ack \#

- seq = 42
	- 42번 문자부터 보내고 있음.
- ack = 77
	- 76번 Byte까지 받았고, 77번 Byte를 받을 차례이다.
- "Hello"
	- H = 42번 문자
	- e = 43번 문자
	- l = 44번 문자
	- l = 45번 문자
	- o = 46번 문자

---

- seq = 77
- ack = 47
- "Hi"
	- H = 77번 문자
	- i = 78번 문자

---

TCP 안에는 아무런 문자도 갖지 않는 패킷도 보낼 수 있다.

ACK만 존재하는 패킷.

- seq = 47
- ack = 79
- ""
	- 47번 문자부터 보내기로 했지만, 아무것도 보내지 않았기 때문에 B 입장에서는 47번부터 받아야 한다.

---

네트워크의 통신을 아끼기 위해서 0.5초 정도 기다린다.

![[Pasted image 20220204165956.png]]

---

Go-back-N기법에 기반함.

- selective repeat은 지금 몇번째 패킷을 받았는지에 대해 알려줘야한다.
	- 1,2,3,4번 패킷을 받고, 5번 패킷은 못받고, 6번 패킷은 받았다.
	- 6번 패킷을 받았다는 것을 알려줘야한다.

- go-back-N
	- TCP는 내가 지금 몇번 패킷을 받을 차례라고 이야기한다.
		- 1,2,3,4번 바이트를 받고, 5번 바이트를 못받고, 6번 바이트를 받았다면.
		- 난 4번 바이트를 받았다고 말해야 한다.
			- 그래야지, 연속적으로 패킷을 받을 수 있다.
	- 내가 몇 번째를 받을 차례라고만 이야기하고, 몇번 바이트는 받았고, 몇번 바이트는 받지 못했다는 것을 전달할 방법이 없음.

## checksum

TCP 세그먼트는 헤더와 payload(바디)로 나뉜다.

전체를 다 더했을때 최종 결과가 1로만 이루어져 있도록(11111111) checksum 부분을 조작한다.

checksum을 뺀 부분의 덧셈 결과(101101110100)를 반전시켜서(1의 보수) checksum(010010001011)을 만든다.

그리고 최종적으로 checksum을 뺀 부분의 덧셈과 checksum을 더하면 최종 결과는 1로만 꽉 차게 된다.

---

중간에 노이즈나 간섭(interference)을 제어하여 내용 변조를 탐지한다.

### 2진수 더하기

0110
0011
1001

---

1101
1011
11000

### checksum 더하기

> carry(올림)가 없다.

0110
0011
1001

---

1101
1011
-
1000
1
-
1001

![[Pasted image 20220204174547.png]]


# UDP

패킷보내라고 하면, 패킷 보낸다.

패킷을 받으면, [[Application Layer]]로 올려주고

이 외에는 하는 일이 없다.

최대한 속도를 생각해서 만드는 프로토콜.