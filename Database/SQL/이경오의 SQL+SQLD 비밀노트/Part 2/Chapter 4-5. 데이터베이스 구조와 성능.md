# 1. 슈퍼/서브 타입 모델

슈퍼/서브 타입 모델은 업무를 구성하는 데이터의 특징을 분석하여 공통점과 차이점을 고려하여 효과적으로 표현할 수 있다.

공통의 부분을 슈퍼 타입 엔티티로 도출하고 공통으로부터 상속받아 다른 엔티티와 차이가 있는 속성에 대해서는 별도의 서브 타입 엔티티로 구분하는 방식이다.

이는 비즈니스의 모습을 정확하게 표현하면서 물리적인 데이터 모델로 변환할 때 선택의 폭을 넓힐 수 있는 장점이 있다.

논리 데이터 모델링에서 슈퍼/서브 타입을 구성하면, 해당 논리 데이터 모델을 물리 데이터 모델로 변환할 경우 아래의 3가지 방식에 따라 변환하게 된다.

![](/bin/db_image/SQLD_4_5_1.png)

논리 데이터 모델링 시 정의한 슈퍼/서브 타입 모델은, 물리 데이터 모델로 변환 시 슈퍼 타입 기준, 서브 타입 기준, 개별 타입 기준으로 변환될 수 있다.

- 슈퍼 타입 기준 (Single 타입, All in One 타입)
	- 슈퍼/서브 타입 모델을 하나의 테이블로 변환한 것이다.
	- Single 타입 기준 혹은 All in One 타입 기준이라고도 한다.\
	```ad-example
	title: 예시

	- 고객 테이블 하나로만 구성한다.

	```

- 서브 타입 기준 (Plus 타입, Super + Sub 타입)
	- 슈퍼/서브 타입을 서브 타입 테이블들로만 변환한 것이다.
	- 도출된 각각의 서브 타입에는 변환 전 슈퍼 엔티티에 있던 칼럼들을 공통적으로 가지고 있다.
	- Plus 타입 기준 혹은 Super + Sub 타입 기준이라고도 한다.
	```ad-example
	title: 예시

	- 개인고객, 법인고객 테이블로 구성한다.

	```
	
- 개별 타입 기준 (OneToOne 타입, 1:1 타입)
	- 슈퍼/서브 타입을 슈퍼 타입과 서브 타입의 각각 개별 테이블로 변환한 것이다.
	- 슈퍼 테이블, 서브 테이블 모두 생성한 것이다.
	- OneToOne 타입 기준 혹은 1:1 타입 기준이라고도 한다.
	```ad-example
	title: 예시

	- 고객, 개인고객, 법인고객 테이블로 구성한다.

	```
	
# 2. 슈퍼/서브 타입 모델 변환의 중요성

논리 데이터 모델링 시 정의한 슈퍼/서브 타입을 물리 모델로 변환하는 것은 성능상 중요하다.

```ad-info
title: 슈퍼 타입/서브 타입 모델 변환의 중요성

- 트랜잭션은 항상 슈퍼 타입 기준으로 처리하는데 테이블은 개별 타입으로 유지되어 UNION 연산에 의해 성능이 저하될 수 있다.
	- 슈퍼 타입 기준으로 테이블을 구성하는 것이 유리한 경우이다.
- 트랜잭션은 항상 서브 타입을 기준으로 처리하는 데 슈퍼 타입으로 되어 있는 경우 성능이 저하되는 경우가 있다.
	- 서브 타입 기준으로 테이블을 구성하는 것이 유리한 경우이다.
- 트랜잭션은 항상 개별 타입 기준으로 처리하는데, 테이블은 슈퍼 타입으로 되어 있어서 불필요하게 많은 양의 데이터가 집약되어 성능이 저하되는 경우가 있다.
	- 개별 타입으로 테이블을 구성하는 것이 유리한 경우이다.

```

따라서 논리 데이터 모델링 시 정의한 슈퍼/서브 타입을 물리 데이터 모델로 변환 시 항상 슈퍼 타입, 서브 타입, 개별 타입 기준 중에서 적절하게 선택을 할 필요가 있다./

# 3. 슈퍼/서브 타입 논리 데이터 모델

아래 그림은 논리 데이터 모델 시 도출한 슈퍼/서브 타입 모델이다. 논리 데이터 모델 단계이므로 아직 어떠한 형태로든 변환하지 않은 상태이다.

![](/bin/db_image/SQLD_4_5_2.png)

# 4. 슈퍼/서브 타입(논리)을 슈퍼 타입(물리)으로 변환

논리 데이터 모델의 슈퍼/서브 타입을 물리 데이터 모델로 변환 시 슈퍼 타입으로 변환하는 것은 슈퍼/서브 타입 전체를 하나의 테이블로 구성하는 것을 뜻한다.

슈퍼/서브 타입의 데이터를 처리 시 항상 통합하여 처리한다고 가정하면 하나의 테이블로 구성하는 것이 성능상 유리할 수 있다. 데이터를 처리할 때 항상 통합하여 처리하는데, 개별로 분리하게 되면 조인 연산 혹은 UNION ALL 연산 등이 빈번해져서 오히려 성능에 부담을 줄 수 있기 때문이다.

이러한 경우 하나의 테이블로 통합하여 테이블을 구축한다. 슈퍼/서브 타입(논리)을 슈퍼 타입(물리)으로 변환하는 기법이다. 아래처럼 당사자 테이블 하나에 모든 데이터를 저장하는 것이다.

![](/bin/db_image/SQLD_4_5_3.png)

# 5. 슈퍼/서브 타입(논리)을 서브 타입(물리)으로 변환

슈퍼/서브 타입의 데이터 처리 시 10만 건인 대리인에 대해서 개별로 처리하는 일이 빈번하다고 가정하자.

만약 슈퍼 타입(물리)으로 변환하여 하나의 테이블로 구성하였다면 10만 건인 대리인의 데이터를 처리하기 위해서 이해관계인(500만 건) 및 매수인(500만 건)의 데이터까지 모두 처리해야 한다. 10만 건의 대리인에 대한 데이터를 처리하려고 할 때 1,010만 건의 데이터를 모두 처리해야 하는 비효율이 발생한다.

이러한 비효율을 제거하기 위해 서브 타입 기준으로 테이블을 변환한다.

![](/bin/db_image/SQLD_4_5_4.png)

서브 타입 기준으로 테이블을 변환한 것으로 각각의 서브 타입으로만 테이블을 설계한 모습이다. 각각의 서브 타입 테이블에는 기존의 슈퍼 타입 엔티티의 속성들이 모두 들어가 있다.

대리인 테이블에는 10만 건만 저장되어 있고, 대리인에 대한 데이터를 처리 시 대리인 테이블만 조회하면 되므로 자연스레 SQL문 성능이 향상될 가능성이 높아진다.

# 6. 슈퍼/서브 타입(논리)을 개별 타입(물리)으로 변환

대부분의 업무 처리가 각각 개별로 발생한다고 가정한다. 당사자, 이해관계인, 대리인, 매수인 각각에 대해 독립적으로 트랜잭션이 발생하면 당사자에 꼭 필요한 칼럼들만을 가지게 하고 이해관계인, 대리인, 매수인에도 꼭 필요한 칼럼들만 가지도록 한다. 즉, 기존의 슈퍼/서브(논리) 타입을 모두 개별 테이블로 변환한 것이다.

![](/bin/db_image/SQLD_4_5_5.png)

# 7. 슈퍼/서브 타입 변환 기법 비교

논리 데이터 모델상의 슈퍼/서브 타입을 물리 데이터 모델로 변환하는 기법을 비교해서 살펴보자.

| 구분                           | 슈퍼 타입                                 | 서브 타입                                           | 개별 타입                                                 |
| ------------------------------ | ----------------------------------------- | --------------------------------------------------- | --------------------------------------------------------- |
| 특징                           | 하나의 테이블                             | 각각의 서브 타입 테이블                             | 슈퍼, 서브 각각의 테이블                                  |
| 확장성                         | 나쁨                                      | 보통                                                | 좋음                                                      |
| 조인 성능                      | 우수함                                    | 나쁨                                                | 나쁨                                                      |
| I/O 성능                       | 나쁨                                      | 좋음                                                | 좋음                                                      |
| 관리 용이성                    | 좋음                                      | 좋지 않음                                           | 좋지 않음                                                 |
| 트랜잭션 유형에 따른 선택 방법 | 전체를 일괄적으로 처리하는 경우 선택한다. | 각각의 서브 타입을 기준으로 처리하는 경우 선택한다. | 각각의 슈퍼, 서브 타입을 기준으로 처리하는 경우 선택한다. |

# 8. PK 칼럼 순서와 성능

테이블에는 기본키(PK)가 존재하고 PK는 단 1개의 칼럼으로 이루어져 있을 수 있고(단일 PK), 2개 이상의 칼럼으로 이루어져 있을 수도 있다.(복합 PK)

복합PK인 경우 PK칼럼의 순서에 따라 SQL문의 성능이 빨라질 수도 있고 느려질 수도 있다.

인구 테이블의 PK가 "행정동코드 + 기준년월 + 인구구분코드 + 연련대구분코드"로 되어 있고, 인구 테이블을 조회할 때 대부분 "기준년월 + 인구구분코드 + 연령대구분코드"로만 조건값을 준다고 가정한다. 이러한 경우 PK칼럼 맨 앞에 존재하는 행정동코드 칼럼에 대해서는 조건값이 들어오지 않기 때문에 테이블 전체 내용을 모두 읽어야만 조회 결과를 가져올 수 있게된다.

=> 테이블 풀 스캔이 발생함.

이런 경우 인구 테이블의 PK를 "기준년월 + 인구구분코드 + 연령대구분코드 + 행정동코드"순으로 변경하면 극적인 성능 향상 효과를 누릴 수 있다.

이러한 방식으로 테이블에 발생되는 트랜잭션 조회 패턴에 따라 복합PK칼럼의 순서를 조정해야 한다.

논리 데이터 모델링 시 식별자(PK)가 여러 개의 속성으로 구성된 복합식별자(복합PK)일 때, PK순서에 대해 성능적으로 고민하지 않고 물리 데이터 모델에 그대로 적용하는 경우 비효율적인 복합PK의 칼럼 순서로 인해 성능 저하가 발생하는 경우가 많다.

정리하자면, 테이블 생성 시 PK는 DBMS에서 자동으로 인덱스도 같이 생성되기 때문에 PK가 복합PK일 경우 복합PK의 칼럼 순서가 성능에 영향을 미치게 된다.

복합PK는 인덱스이고 인덱스의 구성 칼럼이 2개 이상인 인덱스이다. 이 경우 인덱스 구성 칼럼 중 맨 앞에 위치하는 칼럼이 가능한 한 조건절에서 "=" 조건으로 들어와야 한다. 만약 인덱스 선두 칼럼에 대한 조건이 들어오지 않는 경우 일반적으로 인덱스 전체를 읽거나 테이블 전체를 읽게 된다. 전체 데이터를 스캔(검색)하게 되면서 성능 저하가 발생한다.

# 9. PK순서를 잘못 지정하여 성능이 저하된 경우 - 1

![](/bin/db_image/SQLD_4_5_6.png)

입시마스터 테이블의 PK는 "수험번호 + 년도 + 학기" 칼럼으로 구성되어 있다. 이러한 테이블 및 복합PK 구성에서 아래의 SQL문이 가장 빈번하게 호출된다고 가정한다.

![](/bin/db_image/SQLD_4_5_7.png)

"수험번호 + 년도 + 학기" 중 수험번호 칼럼에 대한 조건값이 WHERE절에 들어오지 않으므로 테이블 풀 스캔이 발생하여 200만 건의 데이터를 모두 읽게 되어 성능이 저하된다.

이런 상황에서 복합PK에 대한 인덱스 스캔을 유도하여 SQL문의 성능을 개선시키기 위해 복합 PK의 칼럼 순서를 변경한다.

![](/bin/db_image/SQLD_4_5_8.png)

복합PK의 순서를 "년도 + 학기 + 수험번호"순으로 변경하였다.

![](/bin/db_image/SQLD_4_5_9.png)

복합 PK에 대한 인덱스 스캔을 하게 되므로 테이블 풀 스캔이 사라지고 성능이 개선된다.

# 10. PK순서를 잘못 지정하여 성능이 저하된 경우 - 2

![](/bin/db_image/SQLD_4_5_10.png)

복합PK는 "거래일자 + 사무소코드 + 출금기번호 + 명세표번호"이다. 이 테이블을 기준으로 가장 빈번하게 호출되는 SQL문은 사무소코드 칼럼이 "=" 조건으로 들어오고 거래일자 칼럼을 BETWEEN 조건으로 조회하는 SQL문이다.

![](/bin/db_image/SQLD_4_5_11.png)

거래일자 조건이 BETWEEN 조건으로 들어오기 때문에 인덱스 스캔 효율이 떨어져 성능이 저하된다.

성능 향상을 위해 아래와 같이 PK순서를 조정한다.

![](/bin/db_image/SQLD_4_5_12.png)

복합PK의 순서를 "사무소코드 + 거래일자 + 출금기번호 + 명세표번호"로 변경하였다.

사무소코드 칼럼이 PK칼럼 중 가장 앞에 위치한다. 바로 뒤에는 거래일자 칼럼이 위치한다.

![](/bin/db_image/SQLD_4_5_13.png)

복합PK에서 맨 앞에 위치한 사무소코드 칼럼을 "=" 조건으로 조회하고, 바로 뒤에 위치하는 거래일자 칼럼을 BETWEEN 조건으로 스캔하게 되므로 최적화된 인덱스 스캔이 가능하게 된다.

# 11. 외래키(FK) 칼럼에 대한 인덱스 생성의 중요성

논리 데이터 모델상으로 관계에 의한 외래키(FK) 제약이 걸린 경우, 해당 FK 제약(논리 데이터 모델에서의 관계)이 실제 물리 데이터베이스에 적용될지 안될지는 물리 데이터 모델 설계자의 몫이다.

관계가 있어도 FK 제약조건을 생성하지 않는 경우도 있고, FK 제약조건을 생성했다고 하더라도 해당 FK칼럼에 인덱스를 미생성하는 경우도 있다.

물리적인 외래키(FK)의 생성 여부와는 상관없이 논리적이든 물리적이든 FK 제약조건이 있다면(관계가 있다면) 외래키 칼럼에 대해 인덱스를 생성하는 것이 성능상 유리한 경우가 많다.

![](/bin/db_image/SQLD_4_5_14.png)

학사기준 테이블과 수강신청 테이블을 조인하는 경우가 많다. 이때, 학사기준 테이블에서 특정 행을 읽은 후, 학사기준번호 칼럼으로 수강신청 테이블에서 매칭되는 결과를 조회한다.

수강신청 테이블에 학사기준번호 칼럼에 대한 인덱스가 없을 경우, 조인 연산 시 수강신청 테이블에 대한 테이블 풀 스캔을 학사기준 테이블의 대상 건수만큼 하게 되어 성능 저하가 발생할 수 있다.

이런 경우 수강신청 테이블에 학사기준번호 칼럼으로 이루어진(학사기준번호 칼럼을 선두로하는)인덱스를 생성하면 성능 저하를 미연에 방지할 수 있다.