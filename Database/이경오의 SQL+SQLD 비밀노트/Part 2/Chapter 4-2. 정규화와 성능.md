# 1. 정규화를 통한 성능 향상 전략

정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상현상을 제거하는 것이다.

정규화 작업은 데이터의 중복 속성을 제거하고, 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화된다.

```ad-example
title: 예시

사원 테이블에서 사원번호가 '1001'인 직원의 사원명이 '이경오'라고 하면 사원명 칼럼은 사원 테이블에만 존재하면 된다. 또한 사원번호가 사원명을 결정할 수 있으므로 "사원명은 사원번호에 함수적으로 종속된다."라고 표현한다.

```

![](/bin/db_image/SQLD_4_2_1.png)

정규화된 테이블에 대한 데이터 조회 시에는 성능의 향상 혹은 저하가 일어나고, 입력, 수정, 삭제 시에는 성능이 향상된다.

# 2. 정규화 용어

```ad-info
title: 정규화 용어

- 정규화 (Normalization)
	- 함수적 종속성(FD, Functional Dependency)등과 같은 이론에 근거하여 관계형 데이터베이스 테이블의 삽입/삭제/갱신 이상(Anomaly)현상 발생을 최소화하기 위해 좀 더 작은 단위의 테이블로 설계하는 과정이다.
	- 즉, 정규화는 데이터 모델을 정규형에 맞도록 고치는 과정이다.
- 정규형 (NF, Normal Form)
	- 정규화한 결과라고 할 수 있다.
	- 정규화 결과에 의해 도출된 데이터 모델이 갖춰야 할 특성을 만족한 형태이다.
- 함수적 종속성 (FD, Functional Dependency)
	- 테이블의 특정 칼럼 A의 값을 알면 다른 칼럼 B 값을 알 수 있을 때, 칼럼 B는 카럼 A에 함수적 종속성이 있다고 한다.
	- 예시)
		- 주민번호를 알면 고객명을 알수 있을 때 "고객명은 주민등록번호에 함수적 종속성이 있다"라고 할 수 있다.
- 결정자 (Determinant)
	- 함수적 종속성 설명에서 칼럼 A를 결정자라고 한다.
	- 예시)
		- 주민번호는 고객명을 결정하므로 주민번호는 고객명의 결정자이다.
- 다치종속 (MVD, Multi Valued Dependency)
	- 결정자 칼럼 A에 의해 칼럼 B의 값을 다수 개 알 수 있을 때, 칼럼 B는 칼럼 A에 다치종속되었다고 한다.
	- 예시)
		- 학번을 통해 해당 학생이 수강신청한 다수 개의 수강과목을 알 수 있을 때. "수강과목은 학번에 다치종속된다"라고 할 수 있다.

```

# 3. 정규화 효과 및 장점

정규화는 상호 종속성이 강한 데이터 요소들을 분리, 독립된 개념(엔티티, 테이블)으로 정의하게 됨에 따라 높은 응집도 & 낮은 결합도(High Cohesion & Loose Coupling) 원칙에 충실해지며, 이로 인해 유연성이 극대화된다.

정규화를 통해 개념이 좀 더 세분화됨에 따라 해당 개념에 대한 재활용 가능성이 높아진다. (일반적으로 각종 참조 모델은 정규형을 만족하고 있다.)

정규화는 식별자가 아닌 속성이 한 번만 표현됨에 따라 중복이 최소화된다. 이에 따라 데이터 품질이 확보되고 저장공간이 절약되며, DML 처리 시 성능이 향상된다.

# 4. 정규화 이론

1차, 2차, 3차, 보이스-코드 정규화는 함수 종속성에 근거하여 정규화를 수행하고, 4차 정규화는 속성의 값이 여러 개 발생하는 다치 종속, 5차 정규화는 조인에 의해 발생하는 이상현상 제거로 정규화를 수행한다.

```ad-info
title: 정규화 이론

- 1차 정규화
	- 한 속성에 여러 개의 속성값을 갖거나 같은 유형의 속성이 여러 개인 경우 해당 속성을 분리시킨다.
	- 1차 정규화 작업으로 속성의 원자성을 확보하게 된다.
- 2차 정규화
	- 주식별자에 완전 함수 종속되지 않은 속성을 분리한다.
	- 2차 정규화 작업으로 부분 종속 속성 (Partial Dependency Attribute)이 된 속성을 분리한다.
- 3차 정규화
	- 일반 속성끼리 함수 종속이 발생한 속성을 분리한다.
	- 3차 정규화 작업으로 이행적 종속 속성(Transitive Dependency Attribute)을 분리한다.
- 보이스-코드 정규화
	- 결정자 안에 함수 종속을 가진 주식별자 속성을 분리한다.
- 4차 정규화
	- 다가 종속(Multi-Valued Dependency) 속성을 별도의 엔티티로 분리한다.
- 5차 정규화
	- 결합 종속(Join Dependency)일 경우는 2개 이상의 엔티티로 분리한다.

```

일반적으로 3차 정규화까지 진행하므로 1차, 2차, 3차 정규화까지 정확하게 이해하는 것이 중요하다.

# 5. 제1정규형

제1정규형은 한 속성에 여러 개의 속성값을 갖거나 같은 유형의 속성이 여러 개인 경우 해당 속성을 분리시켜야 함을 뜻한다.

아래는 연락처 속성의 속성값에 전화번호와 이메일주소가 들어있다. 이 경우 제1정규형을 위반했다고 할 수 있다.

![](/bin/db_image/SQLD_4_2_2.png)

![](/bin/db_image/SQLD_4_2_3.png)

기존의 회원 엔티티에 있었던 연락처 속성을 제거하고 회원연락처 엔티티를 추가해서 제1정규형을 만족하게 되었다.

# 6. 제2정규형

제1정규형을 만족하고 모든 PK가 아닌 칼럼은 PK 전체에 종속되어야 한다. PK에 종속적이지 않거나 PK 중 일부 칼럼(들)에만 종속적인 칼럼은 분리되어야 한다.

![](/bin/db_image/SQLD_4_2_4.png)

고객명과 고객등급 속성은 이 엔티티의 복합식별자에 완전 종속되지 않는다. 고객주문 엔티티에서 고객명 및 고객등급 속성은 복합식별자 중 고객아이디 칼럼에만 종속되고 있다. 고객명과 고객등급의 값을 결정하는 기본키를 구성하는 칼럼은 고객아이디 단 하나이며 고객아이디+주문순번의 조합이 아니다.

이런 경우, 갱신 시에 갱신 이상이 발생할 가능성이 존재하고 주문 시마다 고객정보를 중복으로 저장해야 한다. 또한 고객정보를 모르면 주문 자체가 불가능한 구조가 된다.

![](/bin/db_image/SQLD_4_2_5.png)

제2정규화 작업을 통해 복합식별자의 일부 칼럼에만 함수 종속하는 속성이 사라졌으며 제2정규형을 만족하게 되었다.

# 7. 제3정규형

제2정규형을 만족하고 일반 속성들 간에도 함수 종속 관계가 존재하지 않아야 한다. 제3정규형을 만족하려면 일반 속성들 간 종속 관계가 존재하는 것들은 분리되어야 한다.

![](/bin/db_image/SQLD_4_2_6.png)

고객 엔티티의 식별자는 고객아이디이다. 고객아이디 속성을 제외하고 일반 속성인 직업코드와 직업명 속성 간에 함수 종속이 발생하였다. 직업명은 직업코드가 정하기 때문에 직업명은 직업코드에 함수 종속된다고 할 수 있다. 식별자를 제외한 일반 속성 간에 함수 종속이 발생하는 경우 제3정규형을 위반했다고 한다.

![](/bin/db_image/SQLD_4_2_7.png)

# 8. 정규화와 성능

정규화는 전체 데이터베이스 성능에 도움을 준다.

```ad-info
title: 정규화와 성능

- 정규화를 수행한 후, 전에 없었던 조인이 발생하게 되더라도 효율적인 인덱스 사용을 통해 조인 연산을 수행하면 성능상의 단점은 거의 없다.
- 정규화를 수행한 후, 적은 용량의 테이블이 생성된다면 조인 연산 시 적은 용량의 테이블을 먼저 읽어 조인을 수행하면 되므로 성능상 유리하다.
- 정규화가 제대로 되지 않으면 비슷한 종류의 속성이 여러 개가 되어 과도하게 많은 인덱스가 만들어질 수 있다. 정규화를 한다면 하나의 인덱스만 만들어도 된다.

```

# 9. 제1정규화를 통한 성능 개선 - 1

![](/bin/db_image/SQLD_4_2_8.png)

유형기능분류코드와 동일한 속성 형식을 2개 이상의 속성으로 나열하고 있다. 유형기능분류코드에 따라 데이터를 조회하는 경우가 많은 경우 성능 향상을 위해 인덱스를 생성하면 유형기능분류코드 각각에 대해 인덱스를 생성한다. 각각의 유형기능분류코드별 9개의 인덱스를 생성한다.

인덱스가 많아지면 DML 성능에 영향을 주게 되고, 기능분류코드의 유형이 추가될 때마다 추가적으로 인덱스를 생성해야 한다.

![](/bin/db_image/SQLD_4_2_9.png)

모델유형기능분류라는 코드 값을 저장하는 코드성 엔티티를 추가하고 모델코드+유형코드+기능분류코드 속성(칼럼)을 식별자(PK)로 지정하였다. PK 생성 시 자동으로 인덱스가 생성된다.

# 10. 제1정규화를 통한 성능 개선 - 2

일별재고 엔티티 조회 시 인덱스를 생성해야 할 상황이 자주 발생한다. 과도한 인덱스 생성은 관리의 어려움이 따를 수 있다.

![](/bin/db_image/SQLD_4_2_10.png)

일별재고상세 엔티티를 추가해서 과도한 인덱스 생성을 방지하고, 일별재고 엔티티에 집중된 조회를 분산시키는 효과를 낼 수 있다.

# 11. 제2정규화를 통한 성능 개선 - 1

![](/bin/db_image/SQLD_4_2_11.png)

관리번호 속성에만 함수 종속되는 관리점번호, 관서명, 상태, 관서등록일자, 관서해제일자 속성이 있는 것을 알 수 있다. 이 경우 제2정규화를 진행하여 제2정규형으로 만든다.

```ad-info
title: 제2정규형 만족 후 성능상 유리한 점

- 제2정규형을 위반한 데이터 모델에서 데이터를 조회하는 것과 제2정규형을 만족한 데이터 모델에서 데이터를 조회하는 것의 처리 성능은 사용자가 느끼기에는 차이가 없다.
	- PK가 걸려있는 방향으로 조인이 걸려 Unique Index를 곧바로 찾아서 데이터를 조회하기 때문이다.
	- 즉, 효율적인 인덱스 스캔을 통한 조인 연산이 이루어진다면 하나의 테이블에서 조회하는 작업과 비교했을 때 미미하게 성능 차이가 날 뿐 사용자에게 크게 영향을 줄 만큼 성능이 저하되는 일은 없는 것이다.
- 만약 조회 조건을 "관서등록일자가 2020년 이후 관서를 모두 조회하라"로 한다면 제2정규화된 테이블이 훨씬 빠르다.
	- 정규화되지 않은 모델에서는 불필요하게 납부자번호만큼 누적된 데이터를 읽어서 결과를 구분하여 보여주어야 하지만, 정규화된 모델에서는 관서수만큼만 존재하는 데이터를 읽어 곧바로 결과를 보여주기 때문이다.
	- 즉, 정규화를 통해 불필요한 중복 데이터의 저장이 사라지면서, 읽게 되는 데이터의 양도 적어지게 된 것이다.

```

# 12. 제2정규화를 통한 성능 개선 - 2

![](/bin/db_image/SQLD_4_2_12.png)

일자별매각물건 엔티티의 매각시간, 매각장소는 매각일자에 함수 종속된다.

또한 일자별매각물건에는 100만 건의 데이터가 있고, 그중 매각일자의 유일 개수는 5천 개라고 가정한다. 이러한 경우 특정 매각장소에 대한 매각내역 정보를 조회하려면 아래와 같은 SQL문이 필요하다.

![](/bin/db_image/SQLD_4_2_13.png)

SQL문을 보면 일자별매각물건 엔티티에서 매각장소가 '서울 7호'에 해당하는 매각일자의 유일값을 구한 후 매각일자별매각내역 엔티티와 조인하고 있다. 이런 경우 매각일자를 구하기 위해서 100만 건이나 되는 일자별매각물건 엔티티를 전부 스캔해야 한다. 즉, 심각한 성능 저하를 일으키는 SQL문이 될 여지가 있다.

![](/bin/db_image/SQLD_4_2_14.png)

매각기일 엔티티를 추가하여 매각일자를 식별자로 지정하고 매각시간, 매각장소 속성을 일반 속성으로 하였다. 또한 매각기일 엔티티와 매각일자별매각내역 엔티티 간에 관계가 생성되었다.

![](/bin/db_image/SQLD_4_2_15.png)

100만 건이나 되는 일자별매각내역 엔티티를 조회할 필요가 없어졌으며, 5천 건에 불과한 매각기일 엔티티에서 매각장소가 '서울 7호'인 매각일자에 대한 일자별매각내역을 조회하고 있다.

즉, 성능상 훨씬 유리한 SQL문이 되었다. 정규화를 진행하면 업무흐름에 따른 효율적이고 정확한 데이터 모델이 되며, SQL문 성능이 개선되는 효과가 있다.

# 13. 함수적 종속성에 근거한 정규화 수행 필요

함수적 종속성(Functional Dependency)은 데이터들이 어떤 기준값에 의해 종속되는 현상을 지칭하는 것이다. 이때 기준값을 결정자(Determinant)라 하고 종속되는 값을 종속자(Dependent)라고 한다.

![](/bin/db_image/SQLD_4_2_16.png)

![](/bin/db_image/SQLD_4_2_17.png)

위 그림에서는 이름, 출생지, 주소는 주민등록번호에 함수적 종속성을 가진다. 즉, "주민등록번호가 이름, 출생지, 주소를 함수적으로 결정한다"라고 할 수 있다.