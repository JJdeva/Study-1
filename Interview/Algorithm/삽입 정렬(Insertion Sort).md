# 1. 내용

첫 원소는 정렬되어 있다고 가정하고, 두 번째 원소부터 이미 정렬된 원소와 비교하여 값을 삽입함.

자신의 인덱스보다 앞에 있는 원소가 자신보다 클 경우두 원소를 교체한다. 그렇지 않을 경우 다음 원소로 넘어간다.

# 2. Process

1. 두 번째 원소 (A라고 가정)를 선택한다.
2. A보다 인덱스가 작은 원소(B라고 가정)를 선택하여 비교한다.
	1. A가 B보다 작다면 두 값을 교체한다.
		1. 배열의 첫 원소를 만날때까지 반복한다.
	2. A가 B보다 크다면 다음으로 넘어간다.
3. 정렬되지 않은 원소 중 인덱스가 가장 작은 원소를 선택하고 2번부터 반복한다.

# 3. Code

```python

def insertion_sort(array):
	n = len(array)
	
	for i in range(1, n):
		for j in range(i, 0, -1):
			if array[j-1] > array[j]:
				array[j-1], array[j] = array[j], array[j-1]

```

# 4. 복잡도

### A. 시간복잡도

- 최선 : O(n)
	- 대부분의 원소가 정렬되어 있을 경우
- 최악 : O($n^2$)
- 평균 : O($n^2$)

### B. 공간복잡도

O(n)

# 5. 장단점

### A. 장점

- 구현이 간단하고, 코드가 직관적이다.
- 추가적인 메모리 공간이 필요하지 않다.
- 대부분의 원소가 이미 정렬되어 있을 경우, 매우 효율적으로 동작한다.
- 안정 정렬이다.

### B. 단점

- 평균, 최악의 시간복잡도가 O($n^2$)으로 비효율적이다.
- 배열의 길이가 길어질수록 비효율적이다.
