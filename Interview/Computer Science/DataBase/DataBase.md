# 1. 데이터베이스에서 인덱스를 사용하는 이유와 장단점

## A. 인덱스를 사용하는 이유

데이터를 논리적으로 정렬하여 검색과 정렬 속도를 높이기 위해서 사용한다.

## B. 장단점

### a. 장점

검색 속도가 향상된다.

### b. 단점

- 데이터를 삽입, 삭제할때마다 인덱스를 변경해줘야하기 때문에 성능저하가 발생할 수 있다.
- 데이터베이스의 데이터 양이 적을 경우 인덱스 스캔보다 풀 스캔이 더 빠를 수도 있다.

## C. 테이블 풀 스캔과 인덱스 스캔

| 테이블 풀 스캔                        | 인덱스 스캔                                                                 |
| ------------------------------------- | --------------------------------------------------------------------------- |
| 항상 이용 가능                        | 인덱스가 존재해야만 이용 가능                                               |
| 한 번에 여러 개의 블록을 읽음         | 한번에 1개의 블록만 읽음                                                    |
| 많은 데이터 조회 시 성능상 유리       | 극히 일부분의 데이터 조회 시 유리                                           |
| 테이블 랜덤 액세스 부하 없음          | 테이블 랜덤 액세스에 의한 부하가 발생됨                                     |
| 읽었던 블록을 반복해서 읽는 경우 없음 | 읽었던 블록을 반복해서 읽는 비효율 발생 (논리적인 블록 I/O의 개수도 많아짐) |

# 2. Redis와 Mongodb

둘 다 No SQL 방식을 사용한다.

## A. Redis

> 빠른 오픈 소스인 메모리 키 값 데이터 구조 스토어

key-value 형식으로 데이터를 저장한다.

보통 데이터베이스는 하드디스크나 SSD에 저장한다. 하지만 Redis는 메모리(RAM)에 저장해서 디스크 스캐닝이 필요없어 매우 빠른 장점이 존재한다.

캐싱도 가능해 실시간 채팅에 적합하며 세션 공유를 위해 세션 클러스터링에도 활용된다.

### a. RAM은 휘발성인데?

휘발성을 막기 위한 백업 과정이 존재한다.

- snapshot
	- 특정 지점을 설정하고 디스크에 백업
- AOF (Append Only File)
	- 명령(쿼리)들을 저장해두고, 서버가 셧다운되면 재실행해서 다시 만들어 놓는 것

데이터 구조는 key/value 값으로 이루어져 있다. (따라서 Redis는 비정형 데이터를 저장하는 비관계형 데이터베이스 관리 시스템이다.)

### b. value 5가지

1. String (text, binary data)
	- 512MB까지 저장이 가능함
2. set (String 집합)
3. sorted set (set을 정렬해둔 상태)
4. Hash
5. List (양방향 연결리스트도 가능)

## B. Mongodb

document 형식으로 데이터를 저장한다.


# 3. Trigger

데이터베이스에서 Trigger란, Insert, update, delete 와 같은 DML이 수행될 때, 데이터베이스에서 자동적으로 동작하도록 작성된 프로그램을 의미한다. 

쇼핑몰에서 판매 데이터가 추가되면, 일자별 상품 판매 내역을 집계하도록 하는 것을 말한다.

Trigger 내부에 commit과 rollback을 실행할 수 없음

# 4. 프로시저와 함수

## A. 프로시저

어떤 일을 수행하기 위한 일련의 절차

```

[Procedure Start]

1. 쇼핑몰 회원 로그인
2. 구매할 신발 선택
3. 개인정보 및 배송지 선택
4. 결제

[Procedure End]

```

### a. 구조

- DECLARE (선언부)
	- **필수**
	- BEGIN ~ END에서 사용할 변수나 인수에 대한 정의 및 데이터형을 선언
- BEGIN (실행부)
	- **필수**
	- 개발자가 처리하고자 하는 SQL문과 필요한 로직(비교문, 제어문 등)을 정의
- EXCEPTION (예외 처리부)
	- **선택**
	- BEGIN ~ END에서 실행되는 SQL문에 발생된 에러를 처리한다.
- END
	- **필수**
	- BEGIN부터 시작한 SQL문과 필요한 로직의 종료를 선언한다.
	- PL/SQL문의 종료를 선언

프로시저 내부에 commit과 rollback을 실행할 수 있음.

## B. 함수

프로시저의 각 프로세스를 수행하기 위해 필요한 기능들

```

- 쇼핑몰 회원 로그인 기능 중 ID와 PW를 체크하는 기능

```

### a. 프로시저와 차이점

- 반드시 1건을 되돌려줘야 한다.
- SELECT문과 결합하여 호출할 수 있다.

## C. 프로시저와 함수의 차이

- 프로시저
	- 특정 작업을 수행
	- 리턴값을 가질수도 안가질수도 있음
	- 리턴값을 여러 개 가질 수 있음
	- 서버(DB)단에서 기술
	- 수식내에서 사용 불가
	- 단독으로 문장 구성 가능
- 함수
	- 특정 계산을 수행
	- 리턴값을 반드시 가져야 함
	- 리턴값을 오직 하나만 가질수 있음
	- 화면(Client)단에서 기술
	- 수식내에서만 사용 가능
	- 단독으로 문장 구성 불가

# 5. Transaction의 개념

데이터베이스를 상태를 변화시키기 위해서 수행하는 작업의 단위를 의미한다.

SELECT, INSERT, UPDATE, DELETE 작업을 의미한다.

> 사용자가 게시판에 게시글을 올리고(INSERT) 게시판을 구성할 데이터를 다시 SELECT하여 최신 정보를 유지하는 것.
> 여기서 작업단위는 insert문과 select문 둘 다를 합친 것이고 하나의 트랜잭션이라고 한다.

## A. 특징

- 원자성 (Atomicity)
	- 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다.
- 일관성 (Consistency)
	- 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다.
- 독립성 (Isolation)
	- 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다.
- 지속성 (Durability)
	- 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다.

## B. 트랜잭션의 commit, rollback 연산

- commit
	- 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성이 있는 상태에 있을 때, 하나의 트랜잭션이 끝났다는 것을 알려주기 위해 사용하는 연산이다.
	- 이 연산을 사용하면, 수행했던 트랜잭션이 로그에 저장되며, 후에 Rollback 연산을 수행했었던 트랜잭션 단위로 하는 것을 도와준다.
- Rollback
	- 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의 부분적으로만 연산된 결과를 다시 취소한다.

## C. Transaction 관리를 위한 DBMS의 전략

### a. DBMS의 구조

- 크게 2가지 구조
	- Query Processor (질의 처리기)
	- Storage System (저장 시스템)
- 입출력 단위
	- 고정 길이의 page 단위로 disk에 읽거나 쓴다.
- 저장 공간
	- 비휘발성 저장 장치인 disk에 저장, 일부분을 Main Memory에 저장

![](https://d2.naver.com/content/images/2015/06/helloworld-407507-1.png)

### b. Page Buffer Manager or Buffer Manager

DBMS의 Storage System에 속하는 모듈 중 하나로, Main Memory에 유지하는 페이지를 관리하는 모듈

> Buffer 관리 정책에 따라, UNDO 복구와 REDO 복구가 요구되거나 그렇지 않게 되므로, transaction 관리에 매우 중요한 결정을 가져온다.

### c. UNDO

- 필요한 이유
	- 수정된 Page들이 **Buffer 교체 알고리즘에 따라서 디스크에 출력**될 수 있음. Buffer 교체는 transaction과는 무관하게 buffer의 상태에 따라서 결정됨. 이로 인해, 정상적으로 종료되지 않은 transaction이 변경한 page들은 원상 복구 되어야 하는데, 이 복구를 undo라고 함.

#### 1) 2개의 정책 (수정된 페이지를 디스크에 쓰는 시점으로 분류)

- steal
	- 수정된 페이지를 언제든지 디스크에 쓸 수 있는 정책
		- 대부분의 DBMS가 채택하는 Buffer 관리 정책
		- UNDO logging과 복구를 필요로 함
- ¬steal (no-steal)
	- 수정된 페이지들을 EOT (End Of Transaction)까지는 버퍼에 유지하는 정책
		- UNDO 작업이 필요하지 않지만, 매우 큰 메모리 버퍼가 필요함

### d. REDO

이미 commit한 transaction의 수정을 재반영하는 복구 작업

Buffer 관리 정책에 영향을 받음

Transaction이 종료되는 시점에 해당 transaction이 수정한 page를 디스크에 쓸 것인가 아닌가로 기준

- FORCE
	- 수정했던 모든 페이지를 Transaction commit 시점에 disk에 반영
		- transaction이 commit되었을 때 수정된 페이지들이 disk상에 반영되므로 redo 필요 없음
- ¬FORCE (no-FORCE)
	- commit 시점에 반영하지 않는 정책
		- transaction이 disk상의 db에 반영되지 않을 수 있기에 redo 복구가 필요 (대부분의 DBMS 정책)

## D. 트랜잭션 격리 수준 (Transaction Isolation Level)

### a. Isolation level

트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준

### b. Isolation level 필요성

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.

따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 무조건 Locking으로 동시에 수행되는 수 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다.

그렇다고 해서, 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.

따라서 **최대한 효율적인 Locking 방법이 필요함**

### c. Isolation level 종류

#### 1) Read Uncommitted (레벨 0)

> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층

트랜잭션에 처리중이거나, 아직 Commit되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용함.

```
사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다
```

데이터베이스의 일관성을 유지하는 것이 불가능함

#### 2) Read Committed (레벨 1)

> SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층

트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨

Commit이 이루어진 트랜잭션만 조회 가능

SQL 서버가 Default로 사용하는 Isolation Level임

```
사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함
```

#### 3) Repeatable Read (레벨 2)

> 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함

다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능

#### 4) Serializable (레벨 3)

> 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 계층

완벽한 읽기 일관성 모드를 제공함

다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

### d. 선택 시 고려사항

Isolation Level에 대한 조정은, 동시성과 데이터 무결성에 연관되어 있음

동시성을 증가시키면 데이터 무결성에 문제가 발생하고, 데이터 무결성을 유지하면 동시성이 떨어지게 됨.

레벨을 높게 조정할 수록 발생하는 비용이 증가함

### e. 낮은 단계 Isolation Level을 활용할 때 발생하는 현상들

#### 1) Dirty Read

- 커밋되지 않은 수정중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상
- 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경사항을 보게되는 경우

#### 2) Non-Repeatable Read

- 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이하게 나타나는 일관성이 깨진 현상

#### 3) Phantom Read

- 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상
- 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타나는 현상임

# 6. 관계형 데이터베이스 시스템과 NoSQL의 차이점

보통 Spring에서 개발할 때는 MySQL을, Node.js에서는 MongoDB를 주로 사용한다. 하지만 단순히 프레임워크에 따라 결정하는 것은 아니다. 프로젝트를 진행하기에 앞서 적합한데이터베이스를 택해야 한다.

하나의 제시 방법이지 완전한 정답이 정해져 있는 것은 아니다.

SQL을 선택해서 복잡한 JOIN문을 만들지 않도록 설계하여 단접을 없앨 수도 있고

NoSQL을 선택해서 중복 데이터를 줄이는 방법으로 설계해서 단점을 없앨 수도 있다.

## A. SQL (관계형 DB)

SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색을 할 수 있음

관계형 데이터베이스에는 핵심적인 두 가지 특징이 있다.

- 데이터는 정해진 데이터 스키마에 따라 테이블에 저장된다.
- 데이터는 관계를 통해 여러 테이블에 분산된다.

데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다. 해당 구조는 필드의 이름과 데이터 유형으로 정의된다.

따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다. 즉, 스키마를 수정하지 않는 이상은 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나이다.

데이터의 중복을 피하기 위해 **관계**를 이용한다.

![](https://t1.daumcdn.net/cfile/tistory/994D09355C937ECD2D)

하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에 다른 테이블에서 부정확한 데이터를 다룰 위험이 없어지는 장점이 있다.

## B. NoSQL (비관계형 DB)

말 그대로 관계형 DB의 반대다.

스키마도 없고, 관계도 없다.

NoSQL에서는 레코드를 문서(document)라고 부른다.

SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능했다. 하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.

문서(document)는 Json과 비슷한 형태로 가지고 있다. 관계형 데이터베이스처럼 여러 테이블에 나누어 담지 않고, 관련 데이터를 동일한 **컬렉션에 넣는다.**

위 사진에 SQL에서 진행한 Order, User, Products 테이블로 나눈 것을 NoSQL에서는 Orders에 한꺼번에 포함해서 저장하게 된다.

따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다. (NoSQL에는 조인이라는 개념이 존재하지 않음)

조인하고 싶을 때 NoSQL은 컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출하도록 한다. 하지만 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때 NoSQL을 쓰면 상당히 효율적이다.

## C. 확장 개념

두 데이터베이스를 비교할 때 중요한 Scaling 개념도 존재한다.

데이터베이스 서버의 확장성은 **수직성**확장과 **수평적**확장으로 나누어진다.

- 수직적 확장
	- 단순히 데이터베이스 서버의 성능을 향상시키는 것
		- Ex) CPU 업그레이드
- 수평적 확장
	- 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미
		- 하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동

데이터 저장 방식으로 인해 SQL 데이터베이스는 일반적으로 수직적 확장만 지원함

수평적 확장은 NoSQL 데이터베이스에서만 가능

## D. 둘 중 무엇을 선택할까?

어떤 데이터를 다루느냐에 따라 선택을 고려해야 한다.

### a. SQL

#### 1) SQL 장점

- 명확하게 정의된 스키마, 데이터 무결성 보장
- 관계는 각 데이터를 중복없이 한 번만 저장

#### 2) SQL 단점

- 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함.
	- 나중에 수정하기 힘듬
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
- 대체로 수직적 확장만 가능함

#### 3) SQL 데이터베이스 사용이 더 좋을 때

- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우
	- NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### b. NoSQL

#### 1) NoSQL 장점

- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가 가능
- 데이터는 애플리케이션이 필요로 하는 형식으로 저장됨. 데이터 읽어오는 속도가 빨라짐
- 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리 가능

#### 2) NoSQL 단점

- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 떄문에 수정 시 모든 컬렉션에서 수행해야 함
	- SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능

#### 3) NoSQL 데이터베이스 사용이 더 좋을 때

- 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우
	- 막대한 양의 데이터를 다뤄야 하는 경우

# 7. 데이터 무결성

## A. 개체 무결성 (Entity integrity)

모든 테이블이 기본키(primary key)로 선택된 필드(column)를 가져야 한다. 기본키로 선택된 필드는 고유한 값을 가져야 하며, 빈 값은 허용하지 않는다.

## B. 참조 무결성 (Referential Integrity)

참조 관계에 있는 두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것을 말한다.

참조키가 참조하고 있는 기본키 값이 제거된다면, 참조키는 더 이상 존재하지 않는 데이터를 참조하게 된다. 이 경우 참조 무결성을 위배하게 된다.

외래키는 기본키 값 혹은 NULL 값을 가질 수 있다. 그 외의 값은 가질 수 없다.

### a. 참조 무결성을 지키기 위한 기능

- RESTRICTED
	- 레코드를 변경 또는 삭제하고자 할 때 해당 레코드를 참조하고 있는 개체가 있다면, 변경 또는 삭제 연산을 취소한다.
- CASCADE
	- 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체도 변경 또는 삭제된다.

		```ad-example

		# 외래키 관련 제약조건을 삭제하는 경우

		ALTER TABLE [테이블명] DROP FOREIGN KEY [제약조건명];
		
		
		# 삭제와 수정시 CASCADE 옵션 추가
		
		ALTER TABLE [테이블명] ADD CONSTRAINT [제약조건명] FOREIGN KEY([참조키 칼럼]) REFERENCES [참조 테이블]([참조 칼럼]) ON DELETE CASCADE ON UPDATE CASCADE;
		
		```

- SET NULL
	- 레코드를 변경 또는 삭제하면, 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정한다.

		```ad-example

		ALTER TABLE [테이블명] CONSTRAINT [제약조건명] ADD FOREIGN KEY([참조키 칼럼]) REFERENCES [참조 테이블]([참조 칼럼]) ON DELETE SET NULL;

		```


## C. 도메인 무결성 (Domain Integrity)

테이블에 존재하는 필드의 무결성을 보장하기 위한 것으로 필드의 타입, NULL값의 허용 등에 대한 사항을 정의하고, 올바른 데이터가 입력 되었는지를 확인하는 것이다. 

# 8. Key

검색, 정렬시 Tuple을 구분할 수 있는 기준이 되는 Attribute

## A. Candidate Key (후보키)

> Tuple을 유일하게 식별하기 위해 사용하는 속성들의 부분 집합,

2가지 조건 만족

- 유일성
	- Key로 하나의 Tuple을 유일하게 식별할 수 있음
- 최소성
	- 꼭 필요한 속성으로만 구성

## B. Primary Key (기본키)

> 후보키 중 선택한 Main Key

- Null을 가질 수 없음
- 동일한 값이 중복될 수 없음

## C. Alternate Key (대체키)

> 후보키 중 기본키를 제외한 나머지 키 = 보조키

## D. Super Key (슈퍼키)

> 유일성은 만족하지만, 최소성은 만족하지 못하는 키

## E. Foreign Key (외래키)

> 다른 릴레이션의 키본키를 그대로 참조하는 속성의 집합

# 9. Anomaly

정규화를 해야하는 이유는 잘못된 테이블 설계로 인해 Anomaly (이상 현상)가 나타나기 때문이다.

## A. 삽입 이상 (Insertion Anomaly)

기본키가 {Student_ID, Course_ID}인 경우 -> Course를 수강하지 않는 학생은 Course_ID가 없는 현상이 발생함. 결국 Course_ID를 NULL로 입력해야하는데, 기본키는 NULL이 될 수 없으므로 Table에 추가될 수 없음.

굳이 삽입하기 위해서는 **미수강**과 같은 Course_ID를 만들어야 함.

> 불필요한 데이터를 추가해야지, 삽입할 수 있는 상황 = Insertion Anomaly

## B. 갱신 이상 (Update Anomaly)

만약 어떤 학생의 전공(Department)이 "컴퓨터"에서 "음악"으로 바뀌는 경우. 모든 Department를 "음악"으로 바꾸어야 함. 그러나 일부를 깜빡하고 바꾸지 못하는 경우, 제대로 파악 못함.

> 일부만 변경하여, 데이터가 불일치하는 모순의 문제 = Update Anomaly

## C. 삭제 이상 (Deletion Anomaly)

만약 어떤 학생이 수강을 철회하는 경우, {Student_ID, Course_ID, Department, Grade}의 정보 중 Student_ID, Department와 같은 학생에 대한 정보도 함께 삭제됨.

> 튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제 = Deletion Anomaly